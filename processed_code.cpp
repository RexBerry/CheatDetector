/*--------------------------------------*/

#include""#include""#include""#include""#include<cstddef>#include<cstdlib>#include<ostream>namespace urban_jewel_heist{ City::City()noexcept:m_jewel_count(0){for(std::size_t row=0;row<ROW_COUNT;++row){for(std::size_t col=0;col<COL_COUNT;++col){set_cell(row,col,CellType::EMPTY);}}} City::CellType City::cell(std::size_t const row,std::size_t const col)const{return m_grid[row][col];}void City::set_cell(std::size_t const row,std::size_t const col,CellType const value)&{if(m_grid[row][col]==CellType::JEWEL){--m_jewel_count;}if(value==CellType::JEWEL){++m_jewel_count;}m_grid[row][col]=value;}std::size_t City::jewel_count()const noexcept{return m_jewel_count;} void City::update_grid(Robber<Jewel>const robbers[],std::size_t num_robbers,Police const police_officers[],std::size_t num_police)&{ for(std::size_t row=0;row<ROW_COUNT;++row){for(std::size_t col=0;col<COL_COUNT;++col){if(cell(row,col)!=CellType::JEWEL){set_cell(row,col,CellType::EMPTY);}}} for(std::size_t i=0;i<num_robbers;++i){if(!robbers[i].is_active()){ continue;}std::size_t const row=robbers[i].position().y;std::size_t const col=robbers[i].position().x;CellType const curr_cell_value=cell(row,col);switch(curr_cell_value){default:set_cell(row,col,CellType::ONE_ROBBER);break;case CellType::ONE_ROBBER:case CellType::MULTIPLE_ROBBERS:set_cell(row,col,CellType::MULTIPLE_ROBBERS);break;}} for(std::size_t i=0;i<num_police;++i){std::size_t const row=police_officers[i].position().y;std::size_t const col=police_officers[i].position().x;set_cell(row,col,CellType::POLICE);}} std::ostream&operator<<(std::ostream&out,City const&city){for(std::size_t row=0;row<City::ROW_COUNT;++row){for(std::size_t col=0;col<City::COL_COUNT;++col){ out<<static_cast<char>(city.cell(row,col))<<'';} if(row!=City::ROW_COUNT-1){out<<std::endl;}}return out;}}
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_CITY_HPP_#define URBANJEWELHEIST_CITY_HPP_#include""#include""#include<cstddef>#include<ostream>namespace urban_jewel_heist{class City{public: enum CellType:char{EMPTY='',JEWEL='',POLICE='',ONE_ROBBER='',MULTIPLE_ROBBERS='',}; static constexpr std::size_t ROW_COUNT=10;static constexpr std::size_t COL_COUNT=10;City()noexcept;CellType cell(std::size_t row,std::size_t col)const;void set_cell(std::size_t row,std::size_t col,CellType value)&;std::size_t jewel_count()const noexcept;void update_grid(Robber<Jewel>const robbers[],std::size_t num_robbers,Police const police_officers[],std::size_t num_police)&;private: CellType m_grid[ROW_COUNT][COL_COUNT]; std::size_t m_jewel_count;};std::ostream&operator<<(std::ostream&out,City const&city);}#endif
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_CLASSDECLS_HPP_#define URBANJEWELHEIST_CLASSDECLS_HPP_ namespace urban_jewel_heist{struct Point;class City;class Jewel;class Police;template<typename Loot>class Robber;}#endif
/*--------------------------------------*/

#include""#include""#include""#include""#include<cstddef>namespace urban_jewel_heist{ void Jewel::scatter_jewels(City&city,std::size_t const num_jewels){constexpr std::size_t CELL_COUNT=City::ROW_COUNT*City::COL_COUNT; Point coordinates[CELL_COUNT];{std::size_t i=0;for(std::size_t row=0;row<City::ROW_COUNT;++row){for(std::size_t col=0;col<City::COL_COUNT;++col){coordinates[i++]={col,row};}}} shuffle_last_n(coordinates,CELL_COUNT,num_jewels); for(std::size_t i=CELL_COUNT-num_jewels;i<CELL_COUNT;++i){Point const&point=coordinates[i];city.set_cell(point.y,point.x,City::CellType::JEWEL);}} Jewel::Jewel()noexcept:m_original_position{0,0}{recalculate_worth();}Jewel::Jewel(Point const original_position)noexcept:m_original_position(original_position){recalculate_worth();} std::size_t Jewel::worth()const noexcept{return m_worth;}Point Jewel::original_position()const noexcept{return m_original_position;}void Jewel::set_original_position(Point const position)&noexcept{m_original_position=position;recalculate_worth();} void Jewel::recalculate_worth()&noexcept{std::size_t const worth=original_position().x+original_position().y;m_worth=worth;}}
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_JEWEL_HPP_#define URBANJEWELHEIST_JEWEL_HPP_#include""#include""#include<cstddef>namespace urban_jewel_heist{class Jewel{public:static void scatter_jewels(City&city,std::size_t num_jewels);Jewel()noexcept;Jewel(Point original_position)noexcept;std::size_t worth()const noexcept;Point original_position()const noexcept;void set_original_position(Point position)&noexcept;private: std::size_t m_worth; Point m_original_position;void recalculate_worth()&noexcept;};}#endif
/*--------------------------------------*/

#include""#include<cstdlib>constexpr unsigned int SRAND_SEED=573;int main(){std::srand(SRAND_SEED);urban_jewel_heist::UrbanJewelHeist simulation;simulation.run_simulation();simulation.display_summary();return 0;}
/*--------------------------------------*/

#include""namespace urban_jewel_heist{bool Point::operator==(Point const&other)const noexcept{return x==other.x&&y==other.y;}bool Point::operator!=(Point const&other)const noexcept{return!(*this==other);}}
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_POINT_HPP_#define URBANJEWELHEIST_POINT_HPP_#include<cstddef>namespace urban_jewel_heist{struct Point{std::size_t x;std::size_t y;bool operator==(Point const&rhs)const noexcept;bool operator!=(Point const&rhs)const noexcept;};}#endif
/*--------------------------------------*/

#include""#include""#include""#include<cstddef>#include<ostream>namespace urban_jewel_heist{ std::size_t Police::s_next_uid=1; std::size_t Police::s_total_loot_confiscated_worth=0; std::size_t Police::s_total_robbers_caught_count=0; std::size_t Police::total_loot_confiscated_worth()noexcept{return s_total_loot_confiscated_worth;}std::size_t Police::total_robbers_caught_count()noexcept{return s_total_robbers_caught_count;} Police::Police()noexcept:m_uid(s_next_uid++),m_position{0,0},m_loot_confiscated_worth(0),m_robbers_caught_count(0){}Police::Police(Point const position)noexcept:Police(){m_position=position;} Police::~Police()noexcept{s_total_loot_confiscated_worth-=m_loot_confiscated_worth;s_total_robbers_caught_count-=m_robbers_caught_count;} std::size_t Police::uid()const noexcept{return m_uid;}Point Police::position()const noexcept{return m_position;}void Police::set_position(Point const position)&noexcept{m_position=position;}std::size_t Police::loot_confiscated_worth()const noexcept{return m_loot_confiscated_worth;}std::size_t Police::robbers_caught_count()const noexcept{return m_robbers_caught_count;} bool Police::arrest(Robber<Jewel>&robber)noexcept{if(!robber.is_active()||robber.position()!=position()){return false;}std::size_t const loot_worth=robber.calculate_loot_worth();m_loot_confiscated_worth+=loot_worth;s_total_loot_confiscated_worth+=loot_worth;robber.set_is_active(false);++m_robbers_caught_count;++s_total_robbers_caught_count;return true;}void Police::move(Robber<Jewel>robbers[],std::size_t const num_robbers,bool(*const check_and_remove_loot)(Point position))&{ set_position(random_adjacent_point(position()));if(check_and_remove_loot(position())){return;} for(std::size_t i=num_robbers;i--;){Robber<Jewel>&robber=robbers[i];if(robber.position()!=position()){continue;}arrest(robber);}}void Police::output(std::ostream&out,unsigned int const indentation)const{for(unsigned int i=indentation;i--;){out<<'';}out<<""<<uid()<<""<<std::endl;for(unsigned int i=indentation;i--;){out<<'';}out<<"";out<<""<<loot_confiscated_worth()<<std::endl;for(unsigned int i=indentation;i--;){out<<'';}out<<"";out<<""<<robbers_caught_count();}}
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_POLICE_HPP_#define URBANJEWELHEIST_POLICE_HPP_#include""#include""#include<cstddef>#include<ostream>namespace urban_jewel_heist{class Police{public:static std::size_t total_loot_confiscated_worth()noexcept;static std::size_t total_robbers_caught_count()noexcept;Police()noexcept;Police(Point position)noexcept; Police(Police const&other)=delete; Police&operator=(Police const&other)&=delete;~Police()noexcept;std::size_t uid()const noexcept;Point position()const noexcept;void set_position(Point position)&noexcept;std::size_t loot_confiscated_worth()const noexcept;std::size_t robbers_caught_count()const noexcept;bool arrest(Robber<Jewel>&robber)noexcept;void move(Robber<Jewel>robbers[],std::size_t num_robbers,bool(*check_and_remove_loot)(Point position))&;void output(std::ostream&out,unsigned int indentation=0)const;private: static std::size_t s_next_uid; static std::size_t s_total_loot_confiscated_worth; static std::size_t s_total_robbers_caught_count; std::size_t m_uid; Point m_position; std::size_t m_loot_confiscated_worth; std::size_t m_robbers_caught_count;};}#endif
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_ROBBERIMPL_HPP_#define URBANJEWELHEIST_ROBBERIMPL_HPP_#include""#include""#include""#include""#include<cstddef>#include<cstdlib>#include<ostream>#include<string>namespace urban_jewel_heist{ template<typename Loot>std::size_t Robber<Loot>::s_next_uid=1;template<typename Loot>std::size_t Robber<Loot>::s_total_loot_worth=0; template<typename Loot>std::size_t Robber<Loot>::total_loot_worth(){return s_total_loot_worth;} template<typename Loot>Robber<Loot>::Robber():m_uid(s_next_uid++),m_robber_type(RobberType::ORDINARY),m_is_active(true),m_position{0,0},m_loot_count(0){}template<typename Loot>Robber<Loot>::Robber(RobberType robber_type,Point const position):Robber(){m_robber_type=robber_type;m_position=position;} template<typename Loot>Robber<Loot>::~Robber()noexcept{s_total_loot_worth-=calculate_loot_worth();} template<typename Loot>std::size_t Robber<Loot>::uid()const noexcept{return m_uid;}template<typename Loot>typename Robber<Loot>::RobberType Robber<Loot>::robber_type()const noexcept{return m_robber_type;}template<typename Loot>void Robber<Loot>::set_robber_type(RobberType const robber_type)&noexcept{m_robber_type=robber_type;}template<typename Loot>bool Robber<Loot>::is_active()const noexcept{return m_is_active;}template<typename Loot>void Robber<Loot>::set_is_active(bool const active)&noexcept{if(m_is_active&&!active){ s_total_loot_worth-=calculate_loot_worth();m_loot_count=0;}m_is_active=active;}template<typename Loot>Point Robber<Loot>::position()const noexcept{return m_position;}template<typename Loot>void Robber<Loot>::set_position(Point const position)&noexcept{m_position=position;}template<typename Loot>std::size_t Robber<Loot>::loot_count()const noexcept{return m_loot_count;} template<typename Loot>bool Robber<Loot>::is_ordinary()const noexcept{return robber_type()==RobberType::ORDINARY;}template<typename Loot>bool Robber<Loot>::is_greedy()const noexcept{return robber_type()==RobberType::GREEDY;}template<typename Loot>std::size_t Robber<Loot>::calculate_loot_worth()const noexcept{std::size_t loot_worth=0;for(std::size_t i=loot_count();i--;){loot_worth+=m_loot_bag[i].worth();}return loot_worth;}template<typename Loot>Loot const*Robber<Loot>::pick_up_loot(bool(*const check_and_remove_loot)(Point position))&{if(m_loot_count>=LOOT_BAG_SIZE){return nullptr;}bool const gained_loot=check_and_remove_loot(position());if(gained_loot){Loot&loot=m_loot_bag[m_loot_count++];loot.set_original_position(position());s_total_loot_worth+=loot.worth();return&loot;}return nullptr;}template<typename Loot>void Robber<Loot>::redistribute_loot(std::size_t const num_loot,bool(*const check_and_place_loot)(Point position)){ shuffle_last_n(m_loot_bag,loot_count(),num_loot); for(std::size_t i=loot_count()-num_loot;i<loot_count();++i){Loot&loot=m_loot_bag[i];Point place_position=loot.original_position(); while(!check_and_place_loot(place_position)){place_position=random_adjacent_point(place_position);}s_total_loot_worth-=loot.worth();}m_loot_count-=num_loot;}template<typename Loot>void Robber<Loot>::move(Robber<Loot>const robbers[],std::size_t const num_robbers,Police police_officers[],std::size_t const num_police,bool(*const check_and_remove_loot)(Point position),bool(*const check_and_place_loot)(Point position),bool(*const check_loot)(Point position))&{if(!is_active()){return;} for(std::size_t move_num=0;move_num<MAX_GREEDY_MOVES;++move_num){ if(is_greedy()){ set_position(random_adjacent_point_smart(position(),check_loot));}else{set_position(random_adjacent_point(position()));}for(std::size_t i=num_police;i--;){Police&police=police_officers[i];if(police.position()!=position()){continue;}police.arrest(*this);return;}if(is_greedy()){for(std::size_t i=num_robbers;i--;){Robber<Loot>const&other_robber=robbers[i]; if(&other_robber==this){continue;}if(other_robber.position()!=position()){continue;}redistribute_loot(loot_count()/2,check_and_place_loot);}}Loot const*gained_loot=pick_up_loot(check_and_remove_loot);if(gained_loot==nullptr){return;} if(!is_greedy()){return;}bool const loot_has_even_worth=!(gained_loot->worth()&1);if(!loot_has_even_worth){return;}}}template<typename Loot>void Robber<Loot>::output(std::ostream&out,std::string const&loot_name_plural,unsigned int const indentation)const{for(unsigned int i=indentation;i--;){out<<'';}switch(robber_type()){case RobberType::ORDINARY:out<<"";break;case RobberType::GREEDY:out<<"";break;}out<<""<<uid()<<""<<std::endl;for(unsigned int i=indentation;i--;){out<<'';}out<<"";out<<""<<loot_name_plural<<""<<loot_count()<<std::endl;for(unsigned int i=indentation;i--;){out<<'';}out<<"";out<<""<<loot_name_plural<<""<<""<<calculate_loot_worth();}}#endif
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_ROBBER_HPP_#define URBANJEWELHEIST_ROBBER_HPP_#include""#include""#include<cstddef>#include<ostream>#include<string>namespace urban_jewel_heist{template<typename Loot>class Robber{public: enum class RobberType{ORDINARY,GREEDY,}; static constexpr std::size_t LOOT_BAG_SIZE=17;static std::size_t total_loot_worth();Robber();Robber(RobberType robber_type,Point position); Robber(Robber const&other)=delete; Robber&operator=(Robber const&other)&=delete;~Robber()noexcept;std::size_t uid()const noexcept;RobberType robber_type()const noexcept;void set_robber_type(RobberType robber_type)&noexcept;bool is_active()const noexcept;void set_is_active(bool active)&noexcept;Point position()const noexcept;void set_position(Point position)&noexcept;std::size_t loot_count()const noexcept;bool is_ordinary()const noexcept;bool is_greedy()const noexcept;std::size_t calculate_loot_worth()const noexcept;Loot const*pick_up_loot(bool check_and_remove_loot(Point position))&;void move(Robber<Loot>const robbers[],std::size_t num_robbers,Police police_officers[],std::size_t num_police,bool(*check_and_remove_loot)(Point position),bool(*check_and_place_loot)(Point position),bool(*check_loot)(Point position))&;void redistribute_loot(std::size_t num_loot,bool check_and_place_loot(Point position));void output(std::ostream&out,std::string const&loot_name_plural,unsigned int indentation=0)const;private: static constexpr std::size_t MAX_GREEDY_MOVES=3; static std::size_t s_next_uid; static std::size_t s_total_loot_worth; std::size_t m_uid; RobberType m_robber_type;bool m_is_active; Point m_position; Loot m_loot_bag[LOOT_BAG_SIZE]; std::size_t m_loot_count;};}#include""#endif
/*--------------------------------------*/

#include""#include""#include""#include""#include""#include""#include<cstddef>#include<cstdlib>#include<iostream>namespace urban_jewel_heist{ UrbanJewelHeist*UrbanJewelHeist::s_instance=nullptr; UrbanJewelHeist::UrbanJewelHeist()noexcept:m_city{},m_turn_num(0){ Jewel::scatter_jewels(m_city,INITIAL_JEWEL_COUNT); for(std::size_t i=NUM_POLICE;i--;){while(true){std::size_t const row=std::rand()%City::ROW_COUNT;std::size_t const col=std::rand()%City::COL_COUNT;if(m_city.cell(row,col)!=City::CellType::EMPTY){ continue;}m_city.set_cell(row,col,City::CellType::POLICE);m_police_officers[i].set_position({col,row});break;}} for(std::size_t i=NUM_ORDINARY_ROBBERS;i--;){while(true){std::size_t const row=std::rand()%City::ROW_COUNT;std::size_t const col=std::rand()%City::COL_COUNT;if(m_city.cell(row,col)!=City::CellType::EMPTY){ continue;}m_city.set_cell(row,col,City::CellType::ONE_ROBBER);m_robbers[i].set_robber_type(Robber<Jewel>::RobberType::ORDINARY);m_robbers[i].set_position({col,row});break;}} for(std::size_t i=NUM_ORDINARY_ROBBERS;i<NUM_ROBBERS;++i){while(true){std::size_t const row=std::rand()%City::ROW_COUNT;std::size_t const col=std::rand()%City::COL_COUNT;if(m_city.cell(row,col)!=City::CellType::EMPTY){ continue;}m_city.set_cell(row,col,City::CellType::ONE_ROBBER);m_robbers[i].set_robber_type(Robber<Jewel>::RobberType::GREEDY);m_robbers[i].set_position({col,row});break;}}}bool UrbanJewelHeist::run_simulation(bool const display_output){s_instance=this;if(display_output){std::cout<<""<<std::endl;std::cout<<m_city<<std::endl;std::cout<<std::endl;}while(m_turn_num<MAX_NUM_TURNS){ for(std::size_t i=0;i<NUM_ROBBERS;++i){m_robbers[i].move(m_robbers,NUM_ROBBERS,m_police_officers,NUM_POLICE,&check_and_remove_jewel,&check_and_place_jewel,&check_jewel);} for(std::size_t i=0;i<NUM_POLICE;++i){m_police_officers[i].move(m_robbers,NUM_ROBBERS,&check_and_remove_jewel);}m_city.update_grid(m_robbers,NUM_ROBBERS,m_police_officers,NUM_POLICE);++m_turn_num;if(display_output){std::cout<<""<<m_turn_num<<std::endl;std::cout<<m_city<<std::endl;std::cout<<std::endl;}}return true;}void UrbanJewelHeist::display_summary()const{std::cout<<""<<std::endl;std::cout<<std::endl;if(Robber<Jewel>::total_loot_worth()>=ROBBER_WIN_LOOT_WORTH){std::cout<<""""<<ROBBER_WIN_LOOT_WORTH<<""<<std::endl;}else if(m_turn_num>=MAX_NUM_TURNS){std::cout<<""<<MAX_NUM_TURNS<<""<<std::endl;}else{std::cout<<""<<std::endl;}std::cout<<std::endl;std::cout<<""<<std::endl;for(std::size_t i=0;i<NUM_POLICE;++i){m_police_officers[i].output(std::cout,2);std::cout<<std::endl;}std::cout<<std::endl;std::cout<<""<<std::endl;for(std::size_t i=0;i<NUM_ROBBERS;++i){m_robbers[i].output(std::cout,"",2);std::cout<<std::endl;}std::cout<<std::endl;} bool UrbanJewelHeist::check_and_remove_jewel(Point position){if(s_instance->m_city.cell(position.y,position.x)!=City::CellType::JEWEL){return false;}s_instance->m_city.set_cell(position.y,position.x,City::CellType::EMPTY);return true;}bool UrbanJewelHeist::check_and_place_jewel(Point position){if(s_instance->m_city.cell(position.y,position.x)!=City::CellType::EMPTY){return false;}s_instance->m_city.set_cell(position.y,position.x,City::CellType::JEWEL);return true;}bool UrbanJewelHeist::check_jewel(Point position){return s_instance->m_city.cell(position.y,position.x)!=City::CellType::JEWEL;}}
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_URBANJEWELHEIST_HPP_#define URBANJEWELHEIST_URBANJEWELHEIST_HPP_#include""#include""#include""#include""#include""#include<cstddef>namespace urban_jewel_heist{class UrbanJewelHeist{public: static constexpr std::size_t INITIAL_JEWEL_COUNT=47;static constexpr unsigned int MAX_NUM_TURNS=30;static constexpr std::size_t ROBBER_WIN_LOOT_WORTH=438;static constexpr std::size_t NUM_POLICE=1;static constexpr std::size_t NUM_ORDINARY_ROBBERS=2;static constexpr std::size_t NUM_GREEDY_ROBBERS=2;static constexpr std::size_t NUM_ROBBERS=NUM_ORDINARY_ROBBERS+NUM_GREEDY_ROBBERS;UrbanJewelHeist()noexcept;bool run_simulation(bool display_output=true);void display_summary()const;private: static UrbanJewelHeist*s_instance; City m_city; Police m_police_officers[NUM_POLICE]; Robber<Jewel>m_robbers[NUM_ROBBERS]; unsigned int m_turn_num;static bool check_and_remove_jewel(Point position);static bool check_and_place_jewel(Point position);static bool check_jewel(Point position);};}#endif
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_UTILIMPL_HPP_#define URBANJEWELHEIST_UTILIMPL_HPP_#include""#include<cstdlib>namespace urban_jewel_heist{template<typename T>void shuffle_last_n(T arr[],std::size_t const arr_size,std::size_t const num_to_shuffle){for(std::size_t i=arr_size;arr_size-i--<num_to_shuffle;){std::size_t j=std::rand()%(i+1);T tmp=static_cast<T&&>(arr[i]);arr[i]=static_cast<T&&>(arr[j]);arr[j]=static_cast<T&&>(tmp);}}}#endif
/*--------------------------------------*/

#include""#include""#include""#include<cstddef>#include<cstdlib>namespace urban_jewel_heist{Point random_adjacent_point(Point const position)noexcept{ while(true){unsigned int random_offset=std::rand()%8;if(random_offset>=4){++random_offset;}int const dx=random_offset%3-1;int const dy=random_offset/3-1; if(dx<0&&position.x==0){continue;}if(dx>0&&position.x==City::COL_COUNT-1){continue;}if(dy<0&&position.y==0){continue;}if(dy>0&&position.y==City::ROW_COUNT-1){continue;}return{position.x+dx,position.y+dy};}}Point random_adjacent_point_smart(Point position,bool(*const check_loot)(Point position)){bool loot_exists[]{false,false,false,false,false,false,false,false,false}; std::size_t top[]{0,0,0,position.y,position.y,position.y,position.y+1,position.y+1,position.y+1};std::size_t bottom[]{position.y,position.y,position.y,position.y+1,position.y+1,position.y+1,City::ROW_COUNT,City::ROW_COUNT,City::ROW_COUNT};std::size_t left[]{0,0,0,position.x,position.x,position.x,position.x+1,position.x+1,position.x+1,};std::size_t right[]{position.x,position.x,position.x,position.x+1,position.x+1,position.x+1,City::COL_COUNT,City::COL_COUNT,City::COL_COUNT};for(std::size_t i=9;i--;){if(i==4){ continue;}std::size_t row0=top[i];std::size_t row1=bottom[i];std::size_t col0=left[i];std::size_t col1=right[i]; for(std::size_t row=row0;row<row1;++row){for(std::size_t col=col0;col<col1;++col){if(check_loot({col,row})){loot_exists[i]=true;break;}}}}bool any_loot_exists=false;for(std::size_t i=9;i--;){if(loot_exists[i]){any_loot_exists=true;break;}}if(!any_loot_exists){ return random_adjacent_point(position);} while(true){unsigned int random_offset=std::rand()%8;if(random_offset>=4){++random_offset;} if(!loot_exists[random_offset]){continue;}int const dx=random_offset%3-1;int const dy=random_offset/3-1;return{position.x+dx,position.y+dy};}}}
/*--------------------------------------*/

#ifndef URBANJEWELHEIST_UTIL_HPP_#define URBANJEWELHEIST_UTIL_HPP_#include""namespace urban_jewel_heist{Point random_adjacent_point(Point position)noexcept;Point random_adjacent_point_smart(Point position,bool(*check_loot)(Point position));template<typename T>void shuffle_last_n(T arr[],std::size_t arr_size,std::size_t num_to_shuffle);}#include""#endif
/*--------------------------------------*/

#include<iostream>#include<string>const std::string STUDENT_NAME(""); const std::string GREEN_TEXT_COLOR("");const std::string RED_TEXT_COLOR("");const std::string RESET_TEXT_COLOR(""); const std::string ASCII_MOSI(R""""R""""R""""R""""R""""R""""R"");const std::string MOSI_ART_SOURCE("");const std::string MOSI_ART(""""""""""""""""""""""""""""""""""""""""""""""""""); int main(){ std::cout<<GREEN_TEXT_COLOR;std::cout<<""<<STUDENT_NAME<<""<<std::endl; const std::string PROMPT_STRING(RED_TEXT_COLOR+""); std::string school_name;std::string math_teacher_name;std::cout<<std::endl<<""<<std::endl;std::cout<<PROMPT_STRING;std::getline(std::cin,school_name);std::cout<<GREEN_TEXT_COLOR;std::cout<<""<<std::endl;std::cout<<PROMPT_STRING;std::getline(std::cin,math_teacher_name);const std::string PROBLEM_BEGIN(GREEN_TEXT_COLOR+""); const std::string PROBLEM_END("""""");const std::string PROBLEM_RESPONSE(GREEN_TEXT_COLOR+""+STUDENT_NAME+""); char arithmetic_operator;short problem1_lhs; short problem1_rhs; std::cout<<std::endl;std::cout<<PROBLEM_BEGIN<<""<<PROBLEM_END<<std::endl; std::cout<<PROMPT_STRING;std::cin>>problem1_lhs;std::cout<<PROMPT_STRING;std::cin>>arithmetic_operator;std::cout<<PROMPT_STRING;std::cin>>problem1_rhs;std::cout<<std::endl<<PROBLEM_RESPONSE<<std::endl<<problem1_lhs<<""<<arithmetic_operator<<""<<problem1_rhs<<""<<problem1_lhs-problem1_rhs<<std::endl;double problem2_lhs;double problem2_rhs;std::cout<<std::endl;std::cout<<PROBLEM_BEGIN<<""<<PROBLEM_END<<std::endl;std::cout<<PROMPT_STRING;std::cin>>problem2_lhs;std::cout<<PROMPT_STRING;std::cin>>arithmetic_operator;std::cout<<PROMPT_STRING;std::cin>>problem2_rhs;std::cout<<std::endl<<PROBLEM_RESPONSE<<std::endl<<problem2_lhs<<""<<arithmetic_operator<<""<<problem2_rhs<<""<<problem2_lhs/problem2_rhs<<std::endl;int problem3_lhs;int problem3_rhs;std::cout<<std::endl;std::cout<<PROBLEM_BEGIN<<""<<PROBLEM_END<<std::endl;std::cout<<PROMPT_STRING;std::cin>>problem3_lhs;std::cout<<PROMPT_STRING;std::cin>>arithmetic_operator;std::cout<<PROMPT_STRING;std::cin>>problem3_rhs;std::cout<<std::endl<<PROBLEM_RESPONSE<<std::endl<<problem3_lhs<<""<<arithmetic_operator<<""<<problem3_rhs<<""<<problem3_lhs+problem3_rhs<<std::endl; std::cout<<std::endl;std::cout<<""<<STUDENT_NAME<<""<<school_name<<""<<math_teacher_name<<""<<RESET_TEXT_COLOR<<std::endl; std::cout<<std::endl<<""<<std::endl;std::cout<<std::endl;std::cout<<ASCII_MOSI<<std::endl;std::cout<<std::endl;std::cout<<MOSI_ART<<std::endl;std::cout<<""<<MOSI_ART_SOURCE<<""<<std::endl;std::cout<<std::endl;return 0;}
/*--------------------------------------*/

#include<cstdlib>#include<iostream>using namespace std;int main(){ srand(8); cout<<""<<endl; int spells_casted;int wands_owned;bool owns_pet_named_moraine;int money_donated;cout<<endl<<"";cin>>spells_casted;cout<<endl<<"";cin>>wands_owned;cout<<endl<<"""";cin>>owns_pet_named_moraine; cout<<endl<<"""";cin>>money_donated; bool has_donated_money=money_donated>0;int total_points=10*spells_casted+2*wands_owned;int donation_chance_pct=1+10*owns_pet_named_moraine+5*has_donated_money;int raw_fit_score=100*total_points+donation_chance_pct*total_points;float fit_score=static_cast<float>(raw_fit_score)/100; int base_tuition=50''000''000); int scholarships=0+1*raw_fit_score+500*spells_casted+20''000*20'
/*--------------------------------------*/

#include<cctype>#include<cmath>#include<cstdlib>#include<iostream>#include<limits>#include<string>using namespace std; const string ACCEPTANCE_LETTER(""); const int ACCEPTANCE_LETTER_CAESAR_SHIFT=-2; const char FIRST_LOWERCASE_LETTER='';const char FIRST_UPPERCASE_LETTER='';const char LAST_LOWERCASE_LETTER='';const char LAST_UPPERCASE_LETTER='';const int NUM_LETTERS_IN_ALPHABET=LAST_LOWERCASE_LETTER-FIRST_LOWERCASE_LETTER+1;const int MIN_VALID_CAESAR_SHIFT=0;const int MAX_VALID_CAESAR_SHIFT=200;int main(){ int caesar_shift;string message; cout<<""<<endl;cout<<endl;cout<<""<<endl;cout<<endl;cout<<""<<abs(ACCEPTANCE_LETTER_CAESAR_SHIFT)<<""<<endl;cout<<endl;cout<<""<<endl;cout<<endl;cout<<""<<endl;cout<<endl;cout<<""<<endl;cout<<endl; message=ACCEPTANCE_LETTER;caesar_shift=ACCEPTANCE_LETTER_CAESAR_SHIFT;bool first_time=true; while(true){caesar_shift%=NUM_LETTERS_IN_ALPHABET;if(caesar_shift<0){ caesar_shift+=NUM_LETTERS_IN_ALPHABET;if(caesar_shift==NUM_LETTERS_IN_ALPHABET){caesar_shift=0;}} for(char ch:message){if(isalpha(ch)){ char last_letter=isupper(ch)?LAST_UPPERCASE_LETTER:LAST_LOWERCASE_LETTER;if(last_letter-ch<caesar_shift){ch+=caesar_shift-NUM_LETTERS_IN_ALPHABET;}else{ch+=caesar_shift;}} cout<<ch;}cout<<endl<<endl;if(first_time){first_time=false;cout<<""<<endl;}else{ char user_continue;do{cout<<"";cin>>user_continue;cin.ignore(numeric_limits<streamsize>::max(),''); if(user_continue==''){ cout<<endl;cout<<""<<endl;cout<<endl;cout<<""<<endl;exit(0);}}while(user_continue!='');}cout<<endl; char user_encrypt_decrypt;do{cout<<"";cin>>user_encrypt_decrypt;cin.ignore(numeric_limits<streamsize>::max(),'');}while(user_encrypt_decrypt!=''&&user_encrypt_decrypt!=''); bool asked_to_decrypt=user_encrypt_decrypt==''; cout<<""<<(asked_to_decrypt?"":"")<<"";getline(cin,message); do{cout<<""<<MIN_VALID_CAESAR_SHIFT<<""<<MAX_VALID_CAESAR_SHIFT<<"";cin>>caesar_shift;cin.ignore(numeric_limits<streamsize>::max(),'');}while(caesar_shift<MIN_VALID_CAESAR_SHIFT||caesar_shift>MAX_VALID_CAESAR_SHIFT);if(asked_to_decrypt){caesar_shift*=-1;}cout<<(asked_to_decrypt?"":"")<<"";}}
/*--------------------------------------*/

#include<cctype>#include<cstddef>#include<iostream>#include<limits>#include<string>using std::size_t;const std::string INITIAL_LETTER_DATA=""; constexpr char UNUSED_LETTER_DATA='';constexpr char INCORRECT_LETTER_DATA='';constexpr char INCORRECT_POSITION_DATA='';constexpr char CORRECT_LETTER_DATA='';const char FIRST_LETTER='';void greet();void farewell(const std::string&player1_name);void print_instructions(const size_t wordle_word_length,const int guess_limit);void initialize_players(std::string&player1_name,std::string&player2_name,int&friendship_level,const int min_friendship,const int max_friendship);bool update_players_for_new_game(std::string&player1_name,std::string&player2_name,int&friendship_level,const int min_friendship,const int max_friendship,int&num_games);void print_friendship_message(const double normalized_friendship);std::string get_wordle_word_input(const size_t wordle_word_length,const bool is_secret_input=false);std::string validate_word(const std::string&word,const size_t wordle_word_length,const bool is_secret_input=false);void display_feedback(const std::string&key,const std::string&guess);void display_feedback(const std::string&key,const std::string&guess,std::string&letter_data);int end_game(const std::string&secret_word,const bool guessed_correctly,const int guesses_taken,const std::string&player2_name,const int friendship_gain_per_guess);void print_game_summary(const std::string&player1_name,const std::string&player2_name,const int old_friendship_level,const int new_friendship_level,const int game_number);bool is_valid_wordle_word(const std::string&text,const size_t wordle_word_length);char calculate_letter_correctness(const std::string&key,const std::string&guess,const size_t index);char calculate_letter_correctness(const std::string&key,const std::string&guess,const size_t index,std::string&message);size_t count_char(const std::string&st,const char ch,const size_t begin,const size_t end);size_t count_matching_char(const std::string&st1,const std::string&st2,const char ch);std::string get_secret_input(const std::string&error_message,const std::string&prompt,const char fill='');int get_input_in_range(const int min_val,const int max_val);bool get_y_or_n_input();bool try_parse_int(const std::string&text,int&result);std::string num_to_string(const unsigned int num);void set_text_color_error();void set_text_color_highlight();void set_text_color_prompt();void reset_text_color();int main(){static const size_t WORDLE_WORD_LENGTH=5;static const int GUESS_LIMIT=6;static const int MIN_FRIENDSHIP=0;static const int MAX_FRIENDSHIP=100;static const int FRIENDSHIP_GAIN_PER_GUESS=1;reset_text_color(); std::cout<<std::endl;greet();std::cout<<std::endl;print_instructions(WORDLE_WORD_LENGTH,GUESS_LIMIT); std::string player1_name;std::string player2_name;int friendship_level; std::cout<<std::endl;initialize_players(player1_name,player2_name,friendship_level,MIN_FRIENDSHIP,MAX_FRIENDSHIP);int game_number=0;bool play_another_game;do{++game_number;std::cout<<std::endl;print_friendship_message(static_cast<double>(friendship_level-MIN_FRIENDSHIP)/(MAX_FRIENDSHIP-MIN_FRIENDSHIP));std::cout<<std::endl;set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<std::endl; std::cout<<std::endl;set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<""<<std::endl;set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<std::endl;std::string secret_word=get_wordle_word_input(WORDLE_WORD_LENGTH,true);std::string letter_data=INITIAL_LETTER_DATA;bool guessed_correctly=false;int guesses_remaining=GUESS_LIMIT;while(!guessed_correctly&&guesses_remaining>0){ std::cout<<std::endl;set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<guesses_remaining;reset_text_color();std::cout<<""<<std::endl;std::string guess=get_wordle_word_input(WORDLE_WORD_LENGTH);--guesses_remaining; std::cout<<std::endl;display_feedback(secret_word,guess,letter_data); guessed_correctly=guess==secret_word;} std::cout<<std::endl;const int guesses_taken=GUESS_LIMIT-guesses_remaining;const int friendship_gain=end_game(secret_word,guessed_correctly,guesses_taken,player2_name,FRIENDSHIP_GAIN_PER_GUESS); const int old_friendship_level=friendship_level;friendship_level+=friendship_gain;if(friendship_level>MAX_FRIENDSHIP){friendship_level=MAX_FRIENDSHIP;} std::cout<<std::endl;print_game_summary(player1_name,player2_name,old_friendship_level,friendship_level,game_number); std::cout<<std::endl;play_another_game=update_players_for_new_game(player1_name,player2_name,friendship_level,MIN_FRIENDSHIP,MAX_FRIENDSHIP,game_number);}while(play_another_game); std::cout<<std::endl;farewell(player1_name);std::cout<<std::endl;return 0;}void greet(){std::cout<<"";set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<""<<std::endl;}void farewell(const std::string&player1_name){std::cout<<"";set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<""<<std::endl;}void print_instructions(const size_t wordle_word_length,const int guess_limit){set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<""<<std::endl;set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<""<<std::endl;std::cout<<"";set_text_color_prompt();std::cout<<wordle_word_length;reset_text_color();std::cout<<""<<std::endl;std::cout<<"";set_text_color_prompt();std::cout<<"";reset_text_color();std::cout<<""<<std::endl;set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<guess_limit;reset_text_color();std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<"";set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<""<<std::endl;std::cout<<std::endl;display_feedback("","");std::cout<<std::endl;set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<std::endl;}void initialize_players(std::string&player1_name,std::string&player2_name,int&friendship_level,const int min_friendship,const int max_friendship){ set_text_color_prompt();std::cout<<"";reset_text_color();std::getline(std::cin,player1_name);std::cout<<"";set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<""<<std::endl; std::cout<<std::endl;set_text_color_prompt();std::cout<<"";reset_text_color();std::getline(std::cin,player2_name);std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<""<<std::endl; std::cout<<std::endl;set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<""<<std::endl;friendship_level=get_input_in_range(min_friendship,max_friendship);}bool update_players_for_new_game(std::string&player1_name,std::string&player2_name,int&friendship_level,const int min_friendship,const int max_friendship,int&num_games){ set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<""<<std::endl;const bool play_same_player=get_y_or_n_input();if(play_same_player){std::cout<<std::endl;std::cout<<"";set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<""<<std::endl;std::cout<<""<<std::endl;return true;} std::cout<<std::endl;std::cout<<"";set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<num_games;reset_text_color();std::cout<<""<<(num_games==1?"":"")<<"";set_text_color_highlight();std::cout<<friendship_level;reset_text_color();std::cout<<""<<std::endl;std::cout<<""""<<std::endl; std::cout<<std::endl;set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<""""<<std::endl;const bool start_new_game=get_y_or_n_input();if(!start_new_game){return false;} num_games=0;std::cout<<std::endl;std::cout<<""<<std::endl; std::cout<<std::endl;set_text_color_prompt();std::cout<<"";reset_text_color();std::getline(std::cin,player2_name);std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<""<<std::endl; std::cout<<std::endl;set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<""<<std::endl;friendship_level=get_input_in_range(min_friendship,max_friendship);return true;}void print_friendship_message(double normalized_friendship){std::string exclamation;std::string adjective; if(normalized_friendship<0.001){exclamation="";adjective="";}else if(normalized_friendship<0.395){exclamation="";adjective="";}else if(normalized_friendship<0.795){exclamation="";adjective="";}else if(normalized_friendship<0.999){exclamation="";adjective="";}else{exclamation="";adjective="";} set_text_color_highlight();std::cout<<exclamation;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<adjective;reset_text_color();std::cout<<""<<std::endl; if(normalized_friendship<0.001){std::cout<<"";set_text_color_highlight();std::cout<<"";reset_text_color();std::cout<<""<<std::endl;}}std::string get_wordle_word_input(const size_t wordle_word_length,const bool is_secret_input){const std::string prompt=std::string("")+num_to_string(wordle_word_length)+"";const std::string user_input=get_secret_input("",prompt,is_secret_input?'':'');return validate_word(user_input,wordle_word_length,is_secret_input);}std::string validate_word(const std::string&word,const size_t wordle_word_length,const bool is_secret_input){std::string result=word;bool is_valid;do{is_valid=is_valid_wordle_word(result,wordle_word_length);if(!is_valid){const std::string prompt=std::string("")+num_to_string(wordle_word_length)+""; std::cout<<'';result=get_secret_input("",prompt,is_secret_input?'':'');}}while(!is_valid);return result;}void display_feedback(const std::string&key,const std::string&guess){std::string dummy_letter_data=INITIAL_LETTER_DATA;display_feedback(key,guess,dummy_letter_data);}void display_feedback(const std::string&key,const std::string&guess,std::string&letter_data){ static const std::string INCORRECT_LETTER_COLOR="";static const std::string INCORRECT_POSITION_COLOR="";static const std::string CORRECT_LETTER_COLOR="";static const std::string UNUSED_LETTER_COLOR="";static const std::string INCORRECT_LETTER_FEEDBACK="";static const std::string INCORRECT_POSITION_FEEDBACK="";static const std::string CORRECT_LETTER_FEEDBACK=""; for(size_t i=0;i<guess.size();++i){switch(calculate_letter_correctness(key,guess,i)){ case INCORRECT_LETTER_DATA:std::cout<<INCORRECT_LETTER_COLOR;break;case INCORRECT_POSITION_DATA:std::cout<<INCORRECT_POSITION_COLOR;break;case CORRECT_LETTER_DATA:std::cout<<CORRECT_LETTER_COLOR;break;}std::cout<<""<<guess[i]<<"";}reset_text_color();std::cout<<std::endl;std::cout<<std::endl; for(size_t i=0;i<guess.size();++i){std::string explanation;const char correctness=calculate_letter_correctness(key,guess,i,explanation);char&letter_data_to_update=letter_data[guess[i]-FIRST_LETTER];switch(correctness){ case INCORRECT_LETTER_DATA:std::cout<<INCORRECT_LETTER_COLOR<<""<<guess[i]<<"";reset_text_color();std::cout<<""<<INCORRECT_LETTER_FEEDBACK;if(letter_data_to_update==UNUSED_LETTER_DATA){letter_data_to_update=INCORRECT_LETTER_DATA;}break;case INCORRECT_POSITION_DATA:std::cout<<INCORRECT_POSITION_COLOR<<""<<guess[i]<<"";reset_text_color();std::cout<<""<<INCORRECT_POSITION_FEEDBACK;if(letter_data_to_update!=CORRECT_LETTER_DATA){letter_data_to_update=INCORRECT_POSITION_DATA;}break;case CORRECT_LETTER_DATA:std::cout<<CORRECT_LETTER_COLOR<<""<<guess[i]<<"";reset_text_color();std::cout<<""<<CORRECT_LETTER_FEEDBACK;letter_data_to_update=CORRECT_LETTER_DATA;break;}std::cout<<""<<explanation<<std::endl;}std::cout<<std::endl; for(size_t i=0;i<letter_data.size();++i){switch(letter_data[i]){ case UNUSED_LETTER_DATA:std::cout<<UNUSED_LETTER_COLOR;break;case INCORRECT_LETTER_DATA:std::cout<<INCORRECT_LETTER_COLOR;break;case INCORRECT_POSITION_DATA:std::cout<<INCORRECT_POSITION_COLOR;break;case CORRECT_LETTER_DATA:std::cout<<CORRECT_LETTER_COLOR;break;}std::cout<<""<<static_cast<char>(i+FIRST_LETTER)<<"";}reset_text_color();std::cout<<std::endl;}int end_game(const std::string&secret_word,const bool guessed_correctly,const int guesses_taken,const std::string&player2_name,const int friendship_gain_per_guess){int friendship_gain=0;if(guessed_correctly){friendship_gain=friendship_gain_per_guess*guesses_taken; std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<secret_word;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<guesses_taken;reset_text_color();std::cout<<""<<(guesses_taken==1?"":"")<<""<<std::endl;}else{ std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<secret_word;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<guesses_taken;reset_text_color();std::cout<<""<<(guesses_taken==1?"":"")<<""<<std::endl;}return friendship_gain;}void print_game_summary(const std::string&player1_name,const std::string&player2_name,const int old_friendship_level,const int new_friendship_level,const int game_number){set_text_color_highlight();std::cout<<""<<game_number<<"";reset_text_color();std::cout<<std::endl;std::cout<<"";set_text_color_highlight();std::cout<<player1_name;reset_text_color();std::cout<<std::endl;std::cout<<"";set_text_color_highlight();std::cout<<player2_name;reset_text_color();std::cout<<std::endl;std::cout<<"";set_text_color_highlight();std::cout<<old_friendship_level;reset_text_color();std::cout<<"";set_text_color_highlight();std::cout<<new_friendship_level;reset_text_color();std::cout<<std::endl;}bool is_valid_wordle_word(const std::string&text,const size_t wordle_word_length){if(text.size()!=wordle_word_length){return false;}for(char ch:text){if(!isupper(ch)){return false;}}return true;}char calculate_letter_correctness(const std::string&key,const std::string&guess,const size_t index){std::string dummy_message;return calculate_letter_correctness(key,guess,index,dummy_message);}char calculate_letter_correctness(const std::string&key,const std::string&guess,const size_t index,std::string&message){const char guess_ch=guess[index];const char key_ch=key[index];if(guess_ch==key_ch){ message=std::string("")+guess_ch+"";return CORRECT_LETTER_DATA;}const int total_count_in_key=count_char(key,guess_ch,0,key.size());if(total_count_in_key==0){ message=std::string("")+guess_ch+"";return INCORRECT_LETTER_DATA;} const int matching_count=count_matching_char(key,guess,guess_ch);const int previous_count_in_guess=count_char(guess,guess_ch,0,index);const int net_count_after_matching=total_count_in_key-matching_count;const int net_count_after_previous=net_count_after_matching-previous_count_in_guess;if(net_count_after_matching<=0){ message=std::string("")+guess_ch+"";return INCORRECT_LETTER_DATA;}if(net_count_after_previous<=0){ message=std::string("")+guess_ch+""+num_to_string(total_count_in_key)+""+(total_count_in_key==1?"":"")+"";return INCORRECT_LETTER_DATA;} message=std::string("")+guess_ch+"";return INCORRECT_POSITION_DATA;}size_t count_char(const std::string&st,const char ch,const size_t begin,const size_t end){size_t count=0;for(size_t i=begin;i<end;++i){if(st[i]==ch){++count;}}return count;}size_t count_matching_char(const std::string&st1,const std::string&st2,const char ch){size_t count=0;for(size_t i=0;i<st1.size();++i){if(st1[i]==st2[i]&&st1[i]==ch){++count;}}return count;}std::string get_secret_input(const std::string&error_message,const std::string&prompt,const char fill){std::string result; set_text_color_error();std::cout<<error_message;set_text_color_prompt();std::cout<<prompt;reset_text_color();std::getline(std::cin,result);if(fill==0){ return result;} std::cout<<""; set_text_color_error();std::cout<<error_message;set_text_color_prompt();std::cout<<prompt;reset_text_color(); for(size_t i=result.size();i-->0;){std::cout<<fill;} std::cout<<std::endl;return result;}int get_input_in_range(const int min_val,const int max_val){std::string user_input;int user_int_input;bool success;do{set_text_color_prompt();std::cout<<""<<min_val<<""<<max_val<<"";reset_text_color(); std::getline(std::cin,user_input);success=try_parse_int(user_input,user_int_input);success=success&&user_int_input>=min_val&&user_int_input<=max_val;if(!success){set_text_color_error();std::cout<<"";reset_text_color();}}while(!success);return user_int_input;}bool get_y_or_n_input(){std::string user_input;bool user_y_or_n_input;bool success;do{set_text_color_prompt();std::cout<<"";reset_text_color();std::getline(std::cin,user_input);if(user_input==""||user_input==""){user_y_or_n_input=true;success=true;}else if(user_input==""||user_input==""){user_y_or_n_input=false;success=true;}else{success=false;}if(!success){set_text_color_error();std::cout<<"";reset_text_color();}}while(!success);return user_y_or_n_input;}bool try_parse_int(const std::string&text,int&result){if(text.size()==0){ return false;} size_t begin=0;while(begin<text.size()&&text[begin]==''){++begin;}size_t end=text.size();while(end>0&&text[end-1]==''){--end;}if(end<=begin){ return false;} const char first_ch=text[begin];const bool is_negative=first_ch=='';if(is_negative){++begin;if(end<=begin){ return false;}}else if(first_ch<''||first_ch>''){ return false;} int parsed=0;if(is_negative){for(size_t i=begin;i<end;++i){if(parsed<-1&&std::numeric_limits<int>::min()/parsed<10){ return false;}parsed*=10;const char ch=text[i];if(ch<''||ch>''){return false;}const int ones_value=ch-'';if(std::numeric_limits<int>::min()-parsed>-ones_value){ return false;}parsed-=ones_value;}}else{for(size_t i=begin;i<end;++i){if(parsed>1&&std::numeric_limits<int>::max()/parsed<10){ return false;}parsed*=10;const char ch=text[i];if(ch<''||ch>''){return false;}const int ones_value=ch-'';if(std::numeric_limits<int>::max()-parsed<ones_value){ return false;}parsed+=ones_value;}}result=parsed;return true;}std::string num_to_string(const unsigned int num){unsigned int div=1;while(num/div>=10){div*=10;}std::string result;while(div!=0){result+=static_cast<char>(num/div%10+'');div/=10;}return result;}void set_text_color_error(){static const std::string ERROR_COLOR="";std::cout<<ERROR_COLOR;}void set_text_color_highlight(){static const std::string HIGHLIGHT_COLOR="";std::cout<<HIGHLIGHT_COLOR;}void set_text_color_prompt(){static const std::string PROMPT_COLOR="";std::cout<<PROMPT_COLOR;}void reset_text_color(){static const std::string RESET_COLOR="";std::cout<<RESET_COLOR;}
/*--------------------------------------*/

#include""#include""#include""#include""#include""#include""#include""#include<iostream>void update_player_position(Point&player_position,const Rectangle&board_dimensions);void update_alien_position(Point&alien_position,const Point&player_position,const Rectangle&board_dimensions);void update_powerup_position(Point&powerup_position,const Rectangle&board_dimensions);void update_powerup_position(Point&powerup_position,const Rectangle&board_dimensions);bool acquire_powerup(const Point&powerup_position,const Point&player_position,Powerup&powerup,unsigned int&player_lives,unsigned int&player_bullets);void shoot_alien(const Point&guess_position,const Point&alien_position,Powerup&powerup,unsigned int&alien_lives);void shoot_player(const Point&player_last_position,const Point&alien_position,Powerup&player_powerup,unsigned int&player_lives,unsigned int&alien_lives);void display_game_status(int turn_number,unsigned int player_lives,unsigned int alien_lives,unsigned int player_bullets,const Powerup&powerup,const Point&player_position,const Point&alien_position,const Point&powerup_position,const Rectangle&board_dimensions);bool run_galdef_game(const unsigned int initial_player_lives,const unsigned int initial_alien_lives,const unsigned int initial_player_bullets,const Rectangle board_dimensions){ seed_prng(); unsigned int player_lives=initial_player_lives;unsigned int alien_lives=initial_alien_lives;unsigned int player_bullets=initial_player_bullets;Point player_position;player_position.m_x=UNINITIALIZED_X;player_position.m_y=UNINITIALIZED_Y;Point alien_position;alien_position.m_x=UNINITIALIZED_X;alien_position.m_y=UNINITIALIZED_Y;Point powerup_position;powerup_position.m_x=UNINITIALIZED_X;powerup_position.m_y=UNINITIALIZED_Y;Powerup powerup;powerup.m_type=POWERUP_NONE;std::cout<<std::endl; std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<initial_player_lives<<""<<initial_player_bullets<<""<<initial_alien_lives<<""<<std::endl;std::cout<<""<<std::endl;int turn_number=0;while(player_lives>0&&player_bullets>0&&alien_lives>0){++turn_number;std::cout<<std::endl;std::cout<<""<<turn_number<<std::endl; const Point player_last_position=player_position; update_player_position(player_position,board_dimensions);update_alien_position(alien_position,player_position,board_dimensions);update_powerup_position(powerup_position,board_dimensions); bool acquired_new_powerup=acquire_powerup(powerup_position,player_position,powerup,player_lives,player_bullets);if(acquired_new_powerup){ std::cout<<std::endl;std::cout<<"";std::cout<<powerup_description(powerup);std::cout<<std::endl;}else if(equals(player_position,powerup_position)){ std::cout<<std::endl;std::cout<<""""<<std::endl;} bool hit_every_shot=true;for(int i=0;i<2;++i){if(alien_lives<=0){break;}if(player_bullets<=0){ hit_every_shot=false;break;}std::cout<<std::endl; std::cout<<""<<std::endl;Point user_guess=get_user_input_point(board_dimensions); const unsigned int alien_last_lives=alien_lives; shoot_alien(user_guess,alien_position,powerup,alien_lives); player_bullets=clamped_add(player_bullets,-1); if(alien_lives<alien_last_lives){const unsigned int alien_lives_lost=absolute_difference(alien_lives,alien_last_lives); update_alien_position(alien_position,player_position,board_dimensions); if(alien_lives_lost==DAMAGE_DIRECT_HIT_ON_ALIEN){std::cout<<"";}else{std::cout<<"";}std::cout<<""<<alien_lives_lost<<""<<(alien_lives_lost==1?"":"")<<""<<std::endl;std::cout<<""<<std::endl;}else{hit_every_shot=false;std::cout<<""<<std::endl;}}if(hit_every_shot){ player_lives=clamped_add(player_lives,ACCURACY_BONUS_LIVES);player_bullets=clamped_add(player_bullets,ACCURACY_BONUS_BULLETS); std::cout<<std::endl;std::cout<<""""<<ACCURACY_BONUS_LIVES<<""<<(ACCURACY_BONUS_LIVES==1?"":"")<<""<<ACCURACY_BONUS_BULLETS<<""<<(ACCURACY_BONUS_BULLETS==1?"":"")<<""<<std::endl;std::cout<<""<<player_lives<<""<<(player_lives==1?"":"")<<""<<player_bullets<<""<<(player_bullets==1?"":"")<<""<<std::endl;}if(alien_lives>0&&player_bullets>0){if(player_last_position.m_x==UNINITIALIZED_X){std::cout<<std::endl;std::cout<<""<<std::endl;}else{ const unsigned int player_last_lives=player_lives;const unsigned int alien_last_lives=alien_lives; shoot_player(player_last_position,alien_position,powerup,player_lives,alien_lives);std::cout<<std::endl;std::cout<<""<<std::endl;bool damaged_player=player_lives<player_last_lives;bool damaged_alien=alien_lives<alien_last_lives;if(damaged_player){if(damaged_alien){std::cout<<""""<<std::endl;}else{std::cout<<""<<std::endl;}}else if(damaged_alien){std::cout<<""""<<std::endl;}else{std::cout<<""<<std::endl;}if(damaged_alien){const unsigned int alien_lives_lost=absolute_difference(alien_lives,alien_last_lives);std::cout<<""<<alien_lives_lost<<""<<(alien_lives_lost==1?"":"")<<""<<std::endl;}if(damaged_player){const unsigned int player_lives_lost=absolute_difference(player_lives,player_last_lives);std::cout<<""<<player_lives_lost<<""<<(player_lives_lost==1?"":"")<<""<<player_lives<<""<<(player_lives==1?"":"")<<""<<std::endl;}}} update_powerup(powerup);std::cout<<std::endl; display_game_status(turn_number,player_lives,alien_lives,player_bullets,powerup,player_position,alien_position,powerup_position,board_dimensions);}std::cout<<std::endl;bool player_won;if(player_lives<=0){std::cout<<std::endl;std::cout<<""<<std::endl;player_won=false;}else if(player_bullets<=0){std::cout<<std::endl;std::cout<<""<<std::endl;player_won=false;}else{std::cout<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;player_won=true;}std::cout<<""<<std::endl;std::cout<<std::endl;return player_won;}void update_player_position(Point&player_position,const Rectangle&board_dimensions){const Point points_to_avoid[1]={player_position};player_position=random_point(board_dimensions,points_to_avoid,1);}void update_alien_position(Point&alien_position,const Point&player_position,const Rectangle&board_dimensions){const Point points_to_avoid[2]={alien_position,player_position};alien_position=random_point(board_dimensions,points_to_avoid,2);}void update_powerup_position(Point&powerup_position,const Rectangle&board_dimensions){const Point points_to_avoid[1]={powerup_position};powerup_position=random_point(board_dimensions,points_to_avoid,1);}bool acquire_powerup(const Point&powerup_position,const Point&player_position,Powerup&powerup,unsigned int&player_lives,unsigned int&player_bullets){ if(powerup.m_type==POWERUP_BULLETS||powerup.m_type==POWERUP_LIVES){powerup.m_type=POWERUP_NONE;}if(!equals(player_position,powerup_position)){ return false;} int powerup_roll=random_int(0,100-1);if(powerup_roll<50){ if(powerup.m_type>=POWERUP_TEMP_DAMAGE_BOOST){return false;}const int sum_of_coords=player_position.m_x+player_position.m_y;if(sum_of_coords&1){ powerup.m_type=POWERUP_LIVES;}else{ powerup.m_type=POWERUP_BULLETS;}powerup.m_value=sum_of_coords;}else if(powerup_roll<70){ if(powerup.m_type>=POWERUP_TEMP_DAMAGE_BOOST){return false;}powerup.m_type=POWERUP_TEMP_DAMAGE_BOOST;powerup.m_value=random_int(VALUE_TEMP_DAMAGE_BOOST_MIN,VALUE_TEMP_DAMAGE_BOOST_MAX);}else if(powerup_roll<90){ if(powerup.m_type>=POWERUP_TEMP_INVINCIBILITY){return false;}powerup.m_type=POWERUP_TEMP_INVINCIBILITY;powerup.m_value=random_int(VALUE_TEMP_INVINCIBILITY_MIN,VALUE_TEMP_INVINCIBILITY_MAX);}else{ if(powerup.m_type>=POWERUP_SHIELD){return false;}powerup.m_type=POWERUP_SHIELD;powerup.m_value=random_int(VALUE_SHIELD_MIN,VALUE_SHIELD_MAX);}on_powerup_acquisition(powerup,player_lives,player_bullets);return true;}void shoot_alien(const Point&guess_position,const Point&alien_position,Powerup&powerup,unsigned int&alien_lives){if(powerup.m_type==POWERUP_TEMP_DAMAGE_BOOST){--powerup.m_value;}int change_in_lives=0;if(equals(guess_position,alien_position)){ change_in_lives=-DAMAGE_DIRECT_HIT_ON_ALIEN;}else{ const unsigned int abs_dx=absolute_difference(guess_position.m_x,alien_position.m_x);const unsigned int abs_dy=absolute_difference(guess_position.m_y,alien_position.m_y);if((abs_dx==1&&abs_dy==0)||(abs_dx==0&&abs_dy==1)){ change_in_lives=-DAMAGE_INDIRECT_HIT_ON_ALIEN;}}if(change_in_lives==0){ return;}if(powerup.m_type==POWERUP_TEMP_DAMAGE_BOOST&&change_in_lives<0){ change_in_lives-=BONUS_TEMP_DAMAGE_BOOST;} alien_lives=clamped_add(alien_lives,change_in_lives);}void shoot_player(const Point&player_last_position,const Point&alien_position,Powerup&powerup,unsigned int&player_lives,unsigned int&alien_lives){if(powerup.m_type==POWERUP_TEMP_INVINCIBILITY){--powerup.m_value; return;}int change_in_lives=0;if(equals(player_last_position,alien_position)){ change_in_lives=-DAMAGE_DIRECT_HIT_ON_PLAYER;}else{ const unsigned int abs_dx=absolute_difference(alien_position.m_x,player_last_position.m_x);const unsigned int abs_dy=absolute_difference(alien_position.m_y,player_last_position.m_y);if((abs_dx==1&&abs_dy==0)||(abs_dx==0&&abs_dy==1)){ change_in_lives=-DAMAGE_INDIRECT_HIT_ON_ALIEN;}}if(change_in_lives==0){ return;}if(powerup.m_type==POWERUP_SHIELD){ if(change_in_lives+powerup.m_value>=0){alien_lives=clamped_add(alien_lives,change_in_lives);powerup.m_value+=change_in_lives;return;}else{ alien_lives=clamped_add(alien_lives,-powerup.m_value);change_in_lives+=powerup.m_value;powerup.m_value=0;}} player_lives=clamped_add(player_lives,change_in_lives);}void display_game_status(const int turn_number,const unsigned int player_lives,const unsigned int alien_lives,const unsigned int player_bullets,const Powerup&powerup,const Point&player_position,const Point&alien_position,const Point&powerup_position,const Rectangle&board_dimensions){std::cout<<""<<turn_number<<""<<std::endl;std::cout<<std::endl; std::cout<<""<<DISPLAY_SYMBOL_PLAYER<<""<<DISPLAY_SYMBOL_ALIEN<<""<<DISPLAY_SYMBOL_POWERUP<<""<<std::endl;std::cout<<std::endl; std::cout<<"";for(int x=board_dimensions.m_xmin;x<=board_dimensions.m_xmax;++x){std::cout<<''; if(x<10){std::cout<<''<<static_cast<char>(x+'');}else{std::cout<<static_cast<char>(x/10+'')<<static_cast<char>(x%10+'')<<std::endl;}std::cout<<"";}std::cout<<std::endl; std::cout<<"";for(int x=board_dimensions.m_xmin;x<=board_dimensions.m_xmax;++x){std::cout<<"";}std::cout<<std::endl; for(int y=board_dimensions.m_ymin;y<=board_dimensions.m_ymax;++y){ if(y<10){std::cout<<''<<static_cast<char>(y+'');}else{std::cout<<static_cast<char>(y/10+'')<<static_cast<char>(y%10+'')<<std::endl;}std::cout<<''; for(int x=board_dimensions.m_xmin;x<=board_dimensions.m_xmax;++x){Point current_point;current_point.m_x=x;current_point.m_y=y;std::cout<<'';if(equals(current_point,player_position)){std::cout<<DISPLAY_SYMBOL_PLAYER;}else{std::cout<<'';}if(equals(current_point,alien_position)){std::cout<<DISPLAY_SYMBOL_ALIEN;}else{std::cout<<'';}std::cout<<"";}std::cout<<std::endl;std::cout<<""; for(int x=board_dimensions.m_xmin;x<=board_dimensions.m_xmax;++x){Point current_point;current_point.m_x=x;current_point.m_y=y;std::cout<<'';if(equals(current_point,powerup_position)){std::cout<<DISPLAY_SYMBOL_POWERUP;}else{std::cout<<'';}std::cout<<'';std::cout<<"";}std::cout<<std::endl; std::cout<<"";for(int x=board_dimensions.m_xmin;x<=board_dimensions.m_xmax;++x){std::cout<<"";}std::cout<<std::endl;}std::cout<<std::endl; std::cout<<""<<player_bullets<<std::endl;std::cout<<""<<player_lives<<std::endl; std::cout<<""<<alien_lives<<std::endl;std::cout<<std::endl; std::cout<<""<<powerup_description(powerup)<<std::endl;}
/*--------------------------------------*/

#ifndef GALDEF_HPP_#define GALDEF_HPP_#include""bool run_galdef_game(const unsigned int initial_player_lives,const unsigned int initial_alien_lives,const unsigned int initial_player_bullets,Rectangle board_dimensions);#endif
/*--------------------------------------*/

#ifndef GALDEFDEFINES_HPP_#define GALDEFDEFINES_HPP_ constexpr int DEFAULT_BOARD_XMIN=0;constexpr int DEFAULT_BOARD_XMAX=2;constexpr int DEFAULT_BOARD_YMIN=0;constexpr int DEFAULT_BOARD_YMAX=2; constexpr int UNINITIALIZED_X=-100;constexpr int UNINITIALIZED_Y=-100; constexpr char DISPLAY_SYMBOL_PLAYER='';constexpr char DISPLAY_SYMBOL_ALIEN='';constexpr char DISPLAY_SYMBOL_POWERUP=''; constexpr int DEFAULT_INITIAL_PLAYER_LIVES=5;constexpr int DEFAULT_INITIAL_ALIEN_LIVES=10;constexpr int DEFAULT_INITIAL_PLAYER_BULLETS=15; constexpr int DAMAGE_DIRECT_HIT_ON_ALIEN=2;constexpr int DAMAGE_INDIRECT_HIT_ON_ALIEN=1;constexpr int DAMAGE_DIRECT_HIT_ON_PLAYER=2;constexpr int DAMAGE_INDIRECT_HIT_ON_PLAYER=1; constexpr int ACCURACY_BONUS_LIVES=1;constexpr int ACCURACY_BONUS_BULLETS=3;#endif
/*--------------------------------------*/

#include""#include<iostream>#include<limits>Point get_user_input_point(const Rectangle&within_area){int user_guess_x;int user_guess_y;bool is_valid;do{std::cout<<""""<<within_area.m_xmin<<""<<within_area.m_xmax<<""<<within_area.m_ymin<<""<<within_area.m_ymax<<"";std::cin>>user_guess_x>>user_guess_y;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');is_valid=user_guess_x>=within_area.m_xmin&&user_guess_x<=within_area.m_xmax&&user_guess_y>=within_area.m_ymin&&user_guess_y<=within_area.m_ymax;if(!is_valid){std::cout<<"";}}while(!is_valid);Point user_point;user_point.m_x=user_guess_x;user_point.m_y=user_guess_y;return user_point;}
/*--------------------------------------*/

#ifndef INPUTUTIL_HPP_#define INPUTUTIL_HPP_#include""#include""Point get_user_input_point(const Rectangle&within_area);#endif
/*--------------------------------------*/

#include""#include""int main(){Rectangle board_dimensions;board_dimensions.m_xmin=DEFAULT_BOARD_XMIN;board_dimensions.m_xmax=DEFAULT_BOARD_XMAX;board_dimensions.m_ymin=DEFAULT_BOARD_YMIN;board_dimensions.m_ymax=DEFAULT_BOARD_YMAX;run_galdef_game(DEFAULT_INITIAL_PLAYER_LIVES,DEFAULT_INITIAL_ALIEN_LIVES,DEFAULT_INITIAL_PLAYER_BULLETS,board_dimensions);return 0;}
/*--------------------------------------*/

#include<limits>unsigned int absolute_difference(const int val1,const int val2){ if(val2>val1){return val2-val1;}else{return val1-val2;}}unsigned int clamped_add(const unsigned int lhs,const int rhs){ const unsigned int abs_rhs=absolute_difference(rhs,0);if(rhs<0){if(lhs<abs_rhs){return 0;}}else{if(std::numeric_limits<unsigned int>::max()-lhs<abs_rhs){return std::numeric_limits<unsigned int>::max();}}return lhs+rhs;}
/*--------------------------------------*/

#ifndef MATHUTIL_HPP_#define MATHUTIL_HPP_unsigned int absolute_difference(int val1,int val2);unsigned int clamped_add(unsigned int lhs,int rhs);#endif
/*--------------------------------------*/

#include""bool equals(const Point&lhs,const Point&rhs){return lhs.m_x==rhs.m_x&&lhs.m_y==rhs.m_y;}
/*--------------------------------------*/

#ifndef POINT_HPP_#define POINT_HPP_struct Point{int m_x; int m_y;};bool equals(const Point&lhs,const Point&rhs);#endif
/*--------------------------------------*/

#include""#include""std::string powerup_name(int powerup_type);std::string powerup_value_description(const Powerup&powerup);void on_powerup_acquisition(const Powerup&powerup,unsigned int&player_lives,unsigned int&player_bullets){switch(powerup.m_type){case POWERUP_BULLETS:player_bullets+=powerup.m_value;break;case POWERUP_LIVES:player_lives+=powerup.m_value;break;case POWERUP_TEMP_DAMAGE_BOOST:case POWERUP_TEMP_INVINCIBILITY:case POWERUP_SHIELD:break;}}void update_powerup(Powerup&powerup){switch(powerup.m_type){case POWERUP_BULLETS:case POWERUP_LIVES: break;case POWERUP_TEMP_DAMAGE_BOOST:case POWERUP_TEMP_INVINCIBILITY: if(powerup.m_value<=0){powerup.m_type=POWERUP_NONE;}break;case POWERUP_SHIELD: if(powerup.m_value<=0){powerup.m_type=POWERUP_NONE;}break;}}std::string powerup_description(const Powerup&powerup){std::string name=powerup_name(powerup.m_type);std::string value_description=powerup_value_description(powerup);if(value_description.size()==0){return name;}else{return name+""+value_description+"";}}std::string powerup_name(const int powerup_type){switch(powerup_type){default:case POWERUP_NONE:return"";case POWERUP_BULLETS:return"";case POWERUP_LIVES:return"";case POWERUP_TEMP_DAMAGE_BOOST:return""+to_string(BONUS_TEMP_DAMAGE_BOOST)+"";case POWERUP_TEMP_INVINCIBILITY:return"";case POWERUP_SHIELD:return"";}}std::string powerup_value_description(const Powerup&powerup){switch(powerup.m_type){default:case POWERUP_NONE:return"";case POWERUP_BULLETS:return""+to_string(powerup.m_value)+"";case POWERUP_LIVES:return""+to_string(powerup.m_value)+"";case POWERUP_TEMP_DAMAGE_BOOST:case POWERUP_TEMP_INVINCIBILITY:return to_string(powerup.m_value)+"";case POWERUP_SHIELD:return to_string(powerup.m_value)+"";}}
/*--------------------------------------*/

#ifndef POWERUP_HPP_#define POWERUP_HPP_#include<string>struct Powerup{int m_type; int m_value;}; constexpr int POWERUP_NONE=-1; constexpr int POWERUP_BULLETS=1; constexpr int POWERUP_LIVES=2; constexpr int POWERUP_TEMP_DAMAGE_BOOST=3; constexpr int POWERUP_TEMP_INVINCIBILITY=4; constexpr int POWERUP_SHIELD=5; constexpr int BONUS_TEMP_DAMAGE_BOOST=1; constexpr int VALUE_TEMP_DAMAGE_BOOST_MIN=2; constexpr int VALUE_TEMP_DAMAGE_BOOST_MAX=4; constexpr int VALUE_TEMP_INVINCIBILITY_MIN=2; constexpr int VALUE_TEMP_INVINCIBILITY_MAX=3; constexpr int VALUE_SHIELD_MIN=4; constexpr int VALUE_SHIELD_MAX=6;void on_powerup_acquisition(const Powerup&powerup,unsigned int&player_lives,unsigned int&player_bullets);void update_powerup(Powerup&powerup);std::string powerup_description(const Powerup&powerup);#endif
/*--------------------------------------*/

#include""#include""#include<cstdlib>#include<limits>void seed_prng(){std::srand(RANDOM_SEED);}int random_int(const int min,const int max){unsigned int range=absolute_difference(min,max);unsigned int random_val_before_offset;if(range==std::numeric_limits<unsigned int>::max()){random_val_before_offset=std::rand();}else{ random_val_before_offset=std::rand()%(range+1);}return random_val_before_offset+min;}Point random_point(const Rectangle&within_area,const Point points_to_avoid[],const std::size_t num_points_to_avoid){while(true){ Point random_point;random_point.m_x=random_int(within_area.m_xmin,within_area.m_xmax);random_point.m_y=random_int(within_area.m_ymin,within_area.m_ymax);bool is_point_to_avoid=false;for(std::size_t i=0;i<num_points_to_avoid;++i){if(equals(random_point,points_to_avoid[i])){ is_point_to_avoid=true;break;}}if(!is_point_to_avoid){return random_point;}}}
/*--------------------------------------*/

#ifndef RANDOMUTIL_HPP_#define RANDOMUTIL_HPP_#include""#include""#include<cstddef>constexpr unsigned int RANDOM_SEED=612;void seed_prng();int random_int(int min,int max);Point random_point(const Rectangle&within_area,const Point points_to_avoid[],std::size_t num_points_to_avoid);#endif
/*--------------------------------------*/

#include""#include""unsigned int width(const Rectangle&rectangle){return absolute_difference(rectangle.m_xmin,rectangle.m_xmax);}unsigned int height(const Rectangle&rectangle){return absolute_difference(rectangle.m_ymin,rectangle.m_ymax);}
/*--------------------------------------*/

#ifndef RECTANGLE_HPP_#define RECTANGLE_HPP_struct Rectangle{int m_xmin; int m_xmax; int m_ymin; int m_ymax;};unsigned int width(const Rectangle&rectangle);unsigned int height(const Rectangle&rectangle);#endif
/*--------------------------------------*/

#include<string>std::string to_string(const int num){std::string result;int div=1;if(num<0){result+='';while(num/div<=-10){div*=10;}while(div!=0){result+=static_cast<char>(-(num/div%10)+'');div/=10;}}else{while(num/div>=10){div*=10;}while(div!=0){result+=static_cast<char>(num/div%10+'');div/=10;}}return result;}
/*--------------------------------------*/

#ifndef _STRINGUTIL_HPP#define _STRINGUTIL_HPP#include<string>std::string to_string(int value);#endif
/*--------------------------------------*/

#ifndef PA07_DEVELOPER_HPP_#define PA07_DEVELOPER_HPP_#include<string>namespace pa07{struct Developer{ std::string name;std::string country;};}#endif
/*--------------------------------------*/

#include""int main(){pa07::run_ui_to_completion();return 0;}
/*--------------------------------------*/

#include""#include""#include""#include""#include""#include""#include""#include""#include""#include""#include""#include<iostream>#include<limits>namespace pa07{using namespace functors;using sorting::bubble_sort;using sorting::merge_sort;void run_ui_to_completion(){std::cout<<std::endl;std::cout<<""<<std::endl;VideoGameCollection video_game_collection;bool user_exit;do{std::cout<<std::endl;user_exit=run_main_menu_should_exit(video_game_collection);}while(!user_exit);std::cout<<std::endl;std::cout<<""<<std::endl;std::cout<<std::endl;}bool run_main_menu_should_exit(VideoGameCollection&collection){std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<std::endl;const int user_option=util::get_user_input_in_range(1,6);if(user_option!=6){std::cout<<std::endl;}switch(user_option){case 1:user_add_game(collection);break;case 2:user_remove_game(collection);break;case 3:user_display_games(collection);break;case 4:user_search_and_display_games(collection);break;case 5:user_sort_games(collection);break;case 6:return true;}return false;}void user_add_game(VideoGameCollection&collection){static long long game_id=1;std::string user_game_title;std::string user_game_genre;std::string user_game_platform;int user_game_release_year;Developer user_game_developer;std::cout<<""<<std::endl;std::cout<<"";std::getline(std::cin,user_game_title);std::cout<<"";std::getline(std::cin,user_game_genre);std::cout<<"";std::getline(std::cin,user_game_platform);std::cout<<"";std::cin>>user_game_release_year;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');std::cout<<"";std::getline(std::cin,user_game_developer.name);std::cout<<"";std::getline(std::cin,user_game_developer.country);VideoGame game_to_add{game_id++,user_game_title,user_game_genre,user_game_platform,user_game_release_year,user_game_developer};AddGameResult result=add_game(collection,game_to_add);std::cout<<std::endl;switch(result){case AddGameResult::SUCCESS:std::cout<<""<<user_game_title<<""<<std::endl;break;case AddGameResult::OUT_OF_SPACE:std::cout<<""<<VIDEO_GAME_COLLECTION_CAPACITY<<""<<std::endl;break;case AddGameResult::MATCHING_TITLE_FOUND:std::cout<<""""<<std::endl;break;}}void user_remove_game(VideoGameCollection&collection){long long id_to_remove;std::cout<<"";std::cin>>id_to_remove;VideoGame removed_game=remove_game(collection,id_to_remove);std::cout<<std::endl;if(removed_game.id!=id_to_remove){ std::cout<<""<<std::endl;}else{std::cout<<""<<std::endl;display_game(removed_game);}}void user_display_games(VideoGameCollection&collection){display_games(collection);}void user_search_and_display_games(const VideoGameCollection&collection){std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<std::endl;const int user_search_field=util::get_user_input_in_range(1,7);long long user_game_id;std::string user_game_title;std::string user_game_genre;std::string user_game_platform;int user_game_release_year;std::string user_game_developer;std::string user_game_developer_country;switch(user_search_field){case 1: std::cout<<""; std::cin>>user_game_id;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');std::cout<<std::endl;search_and_display_games<CalculatedEqualsMatcher<VideoGame,MemberGetter<VideoGame,long long,&VideoGame::id>>>(collection,user_game_id);break;case 2: std::cout<<""; std::getline(std::cin,user_game_title);std::cout<<std::endl;search_and_display_games<CalculatedEqualsMatcher<VideoGame,MemberGetter<VideoGame,std::string,&VideoGame::title>>>(collection,user_game_title);break;case 3: std::cout<<"";std::getline(std::cin,user_game_genre);std::cout<<std::endl;search_and_display_games<CalculatedEqualsMatcher<VideoGame,MemberGetter<VideoGame,std::string,&VideoGame::genre>>>(collection,user_game_genre);break;case 4: std::cout<<"";std::getline(std::cin,user_game_platform);std::cout<<std::endl;search_and_display_games<CalculatedEqualsMatcher<VideoGame,MemberGetter<VideoGame,std::string,&VideoGame::platform>>>(collection,user_game_platform);break;case 5: std::cout<<"";std::cin>>user_game_release_year;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');std::cout<<std::endl;search_and_display_games<CalculatedEqualsMatcher<VideoGame,MemberGetter<VideoGame,int,&VideoGame::release_year>>>(collection,user_game_release_year);break;case 6: std::cout<<"";std::getline(std::cin,user_game_developer);std::cout<<std::endl;search_and_display_games<CalculatedEqualsMatcher<VideoGame,MemberOfMemberGetter<VideoGame,Developer,&VideoGame::developer,std::string,&Developer::name>>>(collection,user_game_developer);break;case 7: std::cout<<"";std::getline(std::cin,user_game_developer_country);std::cout<<std::endl;search_and_display_games<CalculatedEqualsMatcher<VideoGame,MemberOfMemberGetter<VideoGame,Developer,&VideoGame::developer,std::string,&Developer::country>>>(collection,user_game_developer_country);break;}}unsigned long long user_sort_games(VideoGameCollection&collection){std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<std::endl;const int user_sort_key=util::get_user_input_in_range(1,7);std::cout<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<std::endl;const int user_sorting_algorithm=util::get_user_input_in_range(1,3);VideoGameCollection*collection_copy=nullptr; const bool do_bubble_sort=user_sorting_algorithm==1||user_sorting_algorithm==3;const bool do_merge_sort=user_sorting_algorithm==2||user_sorting_algorithm==3;const bool do_both_sorts=do_bubble_sort&&do_merge_sort;if(do_both_sorts){ collection_copy=new VideoGameCollection(collection);}long long comparison_count=0; using IdComparator=CalculatedLessThanComparator<VideoGame,MemberGetter<VideoGame,long long,&VideoGame::id>>;using TitleComparator=CalculatedLessThanComparator<VideoGame,MemberGetter<VideoGame,std::string,&VideoGame::title>>;using GenreComparator=CalculatedLessThanComparator<VideoGame,MemberGetter<VideoGame,std::string,&VideoGame::genre>>;using PlatformComparator=CalculatedLessThanComparator<VideoGame,MemberGetter<VideoGame,std::string,&VideoGame::platform>>;using ReleaseYearComparator=CalculatedLessThanComparator<VideoGame,MemberGetter<VideoGame,int,&VideoGame::release_year>>;using DeveloperComparator=CalculatedLessThanComparator<VideoGame,MemberOfMemberGetter<VideoGame,Developer,&VideoGame::developer,std::string,&Developer::name>>;using DeveloperCountryComparator=CalculatedLessThanComparator<VideoGame,MemberOfMemberGetter<VideoGame,Developer,&VideoGame::developer,std::string,&Developer::country>>;std::cout<<std::endl;if(do_bubble_sort){switch(user_sort_key){case 1: comparison_count=sort_games<Sorter<VideoGame,IdComparator,bubble_sort<IdComparator,VideoGame>>>(collection);break;case 2: comparison_count=sort_games<Sorter<VideoGame,TitleComparator,bubble_sort<TitleComparator,VideoGame>>>(collection);break;case 3: comparison_count=sort_games<Sorter<VideoGame,GenreComparator,bubble_sort<GenreComparator,VideoGame>>>(collection);break;case 4: comparison_count=sort_games<Sorter<VideoGame,PlatformComparator,bubble_sort<PlatformComparator,VideoGame>>>(collection);break;case 5: comparison_count=sort_games<Sorter<VideoGame,ReleaseYearComparator,bubble_sort<ReleaseYearComparator,VideoGame>>>(collection);break;case 6: comparison_count=sort_games<Sorter<VideoGame,DeveloperComparator,bubble_sort<DeveloperComparator,VideoGame>>>(collection);break;case 7: comparison_count=sort_games<Sorter<VideoGame,DeveloperCountryComparator,bubble_sort<DeveloperCountryComparator,VideoGame>>>(collection);break;}std::cout<<""<<comparison_count<<std::endl;}if(do_both_sorts){collection=static_cast<VideoGameCollection&&>(*collection_copy);delete collection_copy;collection_copy=nullptr;}if(do_merge_sort){switch(user_sort_key){case 1: comparison_count=sort_games<Sorter<VideoGame,IdComparator,merge_sort<IdComparator,VideoGame>>>(collection);break;case 2: comparison_count=sort_games<Sorter<VideoGame,TitleComparator,merge_sort<TitleComparator,VideoGame>>>(collection);break;case 3: comparison_count=sort_games<Sorter<VideoGame,GenreComparator,merge_sort<GenreComparator,VideoGame>>>(collection);break;case 4: comparison_count=sort_games<Sorter<VideoGame,PlatformComparator,merge_sort<PlatformComparator,VideoGame>>>(collection);break;case 5: comparison_count=sort_games<Sorter<VideoGame,ReleaseYearComparator,merge_sort<ReleaseYearComparator,VideoGame>>>(collection);break;case 6: comparison_count=sort_games<Sorter<VideoGame,DeveloperComparator,merge_sort<DeveloperComparator,VideoGame>>>(collection);break;case 7: comparison_count=sort_games<Sorter<VideoGame,DeveloperCountryComparator,merge_sort<DeveloperCountryComparator,VideoGame>>>(collection);break;}std::cout<<""<<comparison_count<<std::endl;}return 0;}}
/*--------------------------------------*/

#ifndef PA07_USERINTERFACE_HPP_#define PA07_USERINTERFACE_HPP_#include""namespace pa07{void run_ui_to_completion();bool run_main_menu_should_exit(VideoGameCollection&collection);void user_add_game(VideoGameCollection&collection);void user_remove_game(VideoGameCollection&collection);void user_display_games(VideoGameCollection&collection);void user_search_and_display_games(const VideoGameCollection&collection);unsigned long long user_sort_games(VideoGameCollection&collection);}#endif
/*--------------------------------------*/

#include""#include""#include<cstddef>#include<iostream>namespace pa07{AddGameResult add_game(VideoGameCollection&collection,const VideoGame&game){if(collection.count>=VIDEO_GAME_COLLECTION_CAPACITY){ return AddGameResult::OUT_OF_SPACE;} for(std::size_t i=0;i<collection.count;++i){if(collection.video_games[i].title==game.title){return AddGameResult::MATCHING_TITLE_FOUND;}}collection.video_games[collection.count++]=game;return AddGameResult::SUCCESS;}VideoGame remove_game(VideoGameCollection&collection,long long game_id){for(std::size_t i=0;i<collection.count;++i){VideoGame&game=collection.video_games[i];if(game.id!=game_id){continue;} VideoGame removed_game(static_cast<VideoGame&&>(game));--collection.count;for(std::size_t j=i;j<collection.count;++j){collection.video_games[j]=static_cast<VideoGame&&>(collection.video_games[j+1]);}return removed_game;} const long long nonmatching_id=game_id==-1?-2:-1;return{nonmatching_id};}void display_games(const VideoGameCollection&collection){if(collection.count==0){ std::cout<<""<<std::endl;}std::cout<<""<<collection.count<<""""<<(collection.count==1?"":"")<<""<<std::endl;for(std::size_t i=0;i<collection.count;++i){std::cout<<std::endl;std::cout<<""<<(i+1)<<std::endl;display_game(collection.video_games[i]);}}}
/*--------------------------------------*/

#ifndef PA07_VIDEOGAMECOLLECTION_HPP_#define PA07_VIDEOGAMECOLLECTION_HPP_#include""#include<cstddef>#include<iostream>namespace pa07{constexpr std::size_t VIDEO_GAME_COLLECTION_CAPACITY=100;struct VideoGameCollection{std::size_t count=0; VideoGame video_games[VIDEO_GAME_COLLECTION_CAPACITY];};enum AddGameResult{SUCCESS,OUT_OF_SPACE,MATCHING_TITLE_FOUND,};AddGameResult add_game(VideoGameCollection&collection,const VideoGame&game);VideoGame remove_game(VideoGameCollection&collection,long long game_id);void display_games(const VideoGameCollection&collection);template<typename Matcher,typename T>void search_and_display_games(const VideoGameCollection&collection,const T&value_to_match){Matcher matches;std::size_t num_matching=0;for(std::size_t i=0;i<collection.count;++i){const VideoGame&game=collection.video_games[i];if(matches(game,value_to_match)){++num_matching;}}if(num_matching==0){std::cout<<""<<std::endl;return;}std::cout<<""<<num_matching<<""<<(num_matching==1?"":"")<<""<<std::endl;std::size_t display_index=0;for(std::size_t i=0;i<collection.count;++i){const VideoGame&game=collection.video_games[i];if(!matches(game,value_to_match)){continue;}++display_index;std::cout<<std::endl;std::cout<<""<<display_index<<std::endl;display_game(game);}}template<typename Sorter>unsigned long long sort_games(VideoGameCollection&collection){Sorter sort;const unsigned long long num_comparisons=sort(&collection.video_games[0],&collection.video_games[collection.count]).comparison_count();return num_comparisons;}}#endif
/*--------------------------------------*/

#include""#include<iostream>namespace pa07{void display_game(const VideoGame&video_game){std::cout<<""<<video_game.id<<std::endl;std::cout<<""<<video_game.title<<std::endl;std::cout<<""<<video_game.genre<<std::endl;std::cout<<""<<video_game.platform<<std::endl;std::cout<<""<<video_game.release_year<<std::endl;std::cout<<""<<video_game.developer.name<<std::endl;std::cout<<""<<video_game.developer.country<<std::endl;}}
/*--------------------------------------*/

#ifndef PA07_VIDEOGAME_HPP_#define PA07_VIDEOGAME_HPP_#include""#include<string>namespace pa07{struct VideoGame{ long long id; std::string title{}; std::string genre{};std::string platform{};int release_year=0;Developer developer{};};void display_game(const VideoGame&video_game);}#endif
/*--------------------------------------*/

#ifndef PA07_FUNCTORS_COMPARATORS_HPP_#define PA07_FUNCTORS_COMPARATORS_HPP_ namespace pa07{namespace functors{template<typename Object,typename ValueCalculator>class CalculatedLessThanComparator{private:ValueCalculator value_calculator_;unsigned long long comparison_count_=0;public:unsigned long long comparison_count(){return comparison_count_;}CalculatedLessThanComparator(){}bool operator()(const Object&lhs,const Object&rhs){++comparison_count_;return value_calculator_(lhs)<value_calculator_(rhs);}};}}#endif
/*--------------------------------------*/

#ifndef PA07_FUNCTORS_MATCHERS_HPP_#define PA07_FUNCTORS_MATCHERS_HPP_ namespace pa07{namespace functors{template<typename Object,typename ValueCalculator>class CalculatedEqualsMatcher{private:ValueCalculator value_calculator_;public:CalculatedEqualsMatcher(){}bool operator()(const Object&object,const decltype(value_calculator_(object))&value){return value_calculator_(object)==value;}};}}#endif
/*--------------------------------------*/

#ifndef PA07_MEMBERGETTERS_HPP_#define PA07_MEBMERGETTERS_HPP_ namespace pa07{namespace functors{template<typename Object,typename Member1,Member1 Object::*member1_ptr>class MemberGetter{public:MemberGetter(){}Member1&operator()(Object&object){return object.*member1_ptr;}const Member1&operator()(const Object&object){return object.*member1_ptr;}};template<typename Object,typename Member1,Member1 Object::*member1_ptr,typename Member2,Member2 Member1::*member2_ptr>class MemberOfMemberGetter{public:MemberOfMemberGetter(){}Member2&operator()(Object&object){return object.*member1_ptr.*member2_ptr;}const Member2&operator()(const Object&object){return object.*member1_ptr.*member2_ptr;}};}}#endif
/*--------------------------------------*/

#ifndef PA07_FUNCTORS_SORTERS_HPP_#define PA07_FUNCTORS_SORTERS_HPP_ namespace pa07{namespace functors{template<typename T,typename Comparator,Comparator(*sort)(T*begin,T*end)>class Sorter{public:Sorter(){}Comparator operator()(T*lhs,T*rhs){return sort(lhs,rhs);}};}}#endif
/*--------------------------------------*/

#ifndef PA07_SORTING_BUBBLESORT_HPP_#define PA07_SORTING_BUBBLESORT_HPP_ namespace pa07{namespace sorting{template<typename Comparator,typename T>Comparator bubble_sort(T*begin,T*end){Comparator less_than;while(end-begin>1){bool is_sorted=true;for(T*p=begin;end-p>1;++p){if(less_than(p[1],*p)){ T tmp(static_cast<T&&>(*p));*p=static_cast<T&&>(p[1]);p[1]=static_cast<T&&>(tmp);is_sorted=false;}}if(is_sorted){break;}--end;}return less_than;}}}#endif
/*--------------------------------------*/

#ifndef PA07_SORTING_MERGESORT_HPP_#define PA07_SORTING_MERGESORT_HPP_#include<cstddef>namespace pa07{namespace sorting{ constexpr std::size_t MERGE_SORT_SMALL_SIZE=8;template<typename Comparator,typename T>inline void insertion_sort_(Comparator&less_than,T*begin,T*end){for(T*p=begin+1;p<end;++p){T tmp(static_cast<T&&>(*p));T*p2;for(p2=p;p2>begin&&less_than(tmp,p2[-1]);--p2){*p2=static_cast<T&&>(p2[-1]);}*p2=static_cast<T&&>(tmp);}}template<typename Comparator,typename T>inline void insertion_sort_into_(Comparator&less_than,T*into,T*begin,T*end){new(into)T(static_cast<T&&>(*begin));begin->~T();for(T*p_from=begin+1,*p_into=into+1;p_from<end;++p_from,++p_into){T tmp(static_cast<T&&>(*p_from));p_from->~T();T*p2;for(p2=p_into;p2>into&&less_than(tmp,p2[-1]);--p2){new(p2)T(static_cast<T&&>(p2[-1]));p2[-1].~T();}new(p2)T(static_cast<T&&>(tmp));}}template<typename Comparator,typename T>inline void merge_into_second_(Comparator&less_than,T*p1,T*end1,T*p2,T*end2){T*into=p2-(end1-p1); if(!less_than(*p2,end1[-1])){ while(p1!=end1){new(into)T(static_cast<T&&>(*p1));p1->~T();++into;++p1;} return;}if(less_than(end2[-1],*p1)){ while(p2!=end2){new(into)T(static_cast<T&&>(*p2));p2->~T();++into;++p2;}while(p1!=end1){new(into)T(static_cast<T&&>(*p1));p1->~T();++into;++p1;}return;} while(true){if(less_than(*p2,*p1)){new(into)T(static_cast<T&&>(*p2));p2->~T();++into;++p2;if(p2==end2){while(p1!=end1){new(into)T(static_cast<T&&>(*p1));p1->~T();++into;++p1;}return;}}else{new(into)T(static_cast<T&&>(*p1));p1->~T();++into;++p1;if(p1==end1){ return;}}}}template<typename Comparator,typename T>void merge_sort_inner_(Comparator&less_than,T*begin,T*end,T*aux,T*offset,bool into_aux){if(static_cast<std::size_t>(end-begin)<=MERGE_SORT_SMALL_SIZE){ if(into_aux){insertion_sort_into_(less_than,begin-offset+aux,begin,end);}else{insertion_sort_(less_than,begin,end);}return;} T*const middle=begin+static_cast<std::size_t>(end-begin)/2;merge_sort_inner_(less_than,begin,middle,aux,offset,!into_aux);merge_sort_inner_(less_than,middle,end,aux,offset,into_aux);T*p1,*end1,*p2,*end2;if(into_aux){p1=begin;end1=middle;p2=middle-offset+aux;end2=end-offset+aux;}else{p1=begin-offset+aux;end1=middle-offset+aux;p2=middle;end2=end;}merge_into_second_(less_than,p1,end1,p2,end2);}template<typename Comparator,typename T>Comparator merge_sort(T*begin,T*end){Comparator less_than;if(end<=begin){return less_than;}const std::size_t slice_size=static_cast<std::size_t>(end-begin);if(slice_size<=MERGE_SORT_SMALL_SIZE){ insertion_sort_(less_than,begin,end);return less_than;}const std::size_t half_size=slice_size/2;T*const aux=static_cast<T*>(::operator new(half_size*sizeof(T)));T*const middle=begin+half_size; merge_sort_inner_(less_than,middle,end,aux,middle,false);merge_sort_inner_(less_than,begin,middle,aux,begin,true);merge_into_second_(less_than,aux,aux+half_size,middle,end);::operator delete(aux);return less_than;}}}#endif
/*--------------------------------------*/

#include<iostream>#include<limits>namespace pa07{namespace util{int get_user_input_in_range(const int min,const int max){int user_num;bool valid_input_given;do{std::cout<<""<<min<<""<<max<<"";std::cin>>user_num;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');valid_input_given=min<=user_num&&user_num<=max;if(!valid_input_given){ std::cout<<"";}}while(!valid_input_given);return user_num;}}}
/*--------------------------------------*/

#ifndef PA07_UTIL_USERINPUT_HPP_#define PA07_UTIL_USERINPUT_HPP_ namespace pa07{namespace util{int get_user_input_in_range(int min,int max);}}#endif
/*--------------------------------------*/

#include""#include""#include<cstddef>namespace pa08{std::size_t JediTournament::num_participants()const{return num_participants_;}Jedi&JediTournament::participant_at_index(std::size_t const index)&{return participants_[index];}Jedi const&JediTournament::participant_at_index(std::size_t const index)const&{return participants_[index];}Jedi&&JediTournament::participant_at_index(std::size_t const index)&&{return static_cast<Jedi&&>(participants_[index]);}Jedi const&&JediTournament::participant_at_index(std::size_t const index)const&&{return static_cast<Jedi const&&>(participants_[index]);}bool JediTournament::add_participant(Jedi const&jedi)&{if(num_participants_>=MAX_NUM_PARTICIPANTS){ return false;}participants_[num_participants_++]=jedi;return true;}bool JediTournament::add_participant(Jedi&&jedi)&{if(num_participants_>=MAX_NUM_PARTICIPANTS){ return false;}participants_[num_participants_++]=static_cast<Jedi&&>(jedi);return true;}void JediTournament::create_score_matrix(int(&score_matrix)[MAX_NUM_PARTICIPANTS][MAX_NUM_PARTICIPANTS])const{for(std::size_t i=0;i<num_participants();++i){for(std::size_t j=0;j<num_participants();++j){score_matrix[i][j]=Jedi::calculate_score(participant_at_index(i),participant_at_index(j));}}}}
/*--------------------------------------*/

#ifndef PA08_JEDITOURNAMENT_HPP_#define PA08_JEDITOURNAMENT_HPP_#include""#include<cstddef>namespace pa08{class JediTournament{public:static constexpr std::size_t MAX_NUM_PARTICIPANTS=10;std::size_t num_participants()const;Jedi&participant_at_index(std::size_t index)&;Jedi const&participant_at_index(std::size_t index)const&;Jedi&&participant_at_index(std::size_t index)&&;Jedi const&&participant_at_index(std::size_t index)const&&;bool add_participant(Jedi const&jedi)&;bool add_participant(Jedi&&jedi)&;void create_score_matrix(int(&score_matrix)[MAX_NUM_PARTICIPANTS][MAX_NUM_PARTICIPANTS])const;private:Jedi participants_[MAX_NUM_PARTICIPANTS];std::size_t num_participants_=0;};}#endif
/*--------------------------------------*/

#include""#include<cmath>namespace pa08{int Jedi::calculate_score(Jedi const&jedi1,Jedi const&jedi2){int const force_strength_diff=std::abs(jedi1.force_strength-jedi2.force_strength);int const skill_level_diff=std::abs(jedi1.skill_level-jedi2.skill_level);int const pairing_score=force_strength_diff+skill_level_diff;return pairing_score;}}
/*--------------------------------------*/

#ifndef PA08_JEDI_HPP_#define PA08_JEDI_HPP_#include<string>namespace pa08{struct Jedi{std::string name;std::string lightsaber_color;int skill_level;int force_strength;static int calculate_score(Jedi const&jedi1,Jedi const&jedi2);};}#endif
/*--------------------------------------*/

#include""#include<cstdlib>int main(){std::srand(0504);pa08::run_ui_to_completion();return 0;}
/*--------------------------------------*/

#include""#include""#include""#include<cstddef>#include<cstdlib>namespace pa08{void pairing_algorithm_greedy(JediTournament const&tournament,int const(&score_matrix)[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS],Jedi const*duel_pairs[][2]){ bool chosen[JediTournament::MAX_NUM_PARTICIPANTS]{}; std::size_t const num_duels=tournament.num_participants()/2;std::size_t jedi_index=0;for(std::size_t duel_index=0;duel_index<num_duels;++duel_index){while(chosen[jedi_index]){++jedi_index;}chosen[jedi_index]=true; int best_pair_score=-1; std::size_t best_pair_other_jedi_index=0;for(std::size_t other_jedi_index=jedi_index+1;other_jedi_index<tournament.num_participants();++other_jedi_index){if(chosen[other_jedi_index]){continue;}int const score=score_matrix[jedi_index][other_jedi_index];if(best_pair_score==-1||score<best_pair_score){best_pair_score=score;best_pair_other_jedi_index=other_jedi_index;}}chosen[best_pair_other_jedi_index]=true;duel_pairs[duel_index][0]=&tournament.participant_at_index(jedi_index);duel_pairs[duel_index][1]=&tournament.participant_at_index(best_pair_other_jedi_index);}}void pairing_algorithm_random(JediTournament const&tournament,int const(&score_matrix)[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS],Jedi const*duel_pairs[][2],unsigned int const num_iterations){std::size_t const num_duels=tournament.num_participants()/2; std::size_t shuffled_jedi[JediTournament::MAX_NUM_PARTICIPANTS];for(std::size_t i=tournament.num_participants();i-->0;){shuffled_jedi[i]=i;}int best_score=-1;for(unsigned int iteration=num_iterations;iteration>0;--iteration){ for(std::size_t i=tournament.num_participants();i>1;--i){ std::size_t const swap_index=static_cast<std::size_t>(std::rand())*i/(static_cast<std::size_t>(RAND_MAX)+1);std::size_t&swap1=shuffled_jedi[i-1];std::size_t&swap2=shuffled_jedi[swap_index]; std::size_t const tmp=swap1;swap1=swap2;swap2=tmp;} int score=0;for(std::size_t i=tournament.num_participants();i>0;i-=2){score+=score_matrix[shuffled_jedi[i-1]][shuffled_jedi[i-2]];if(score>=best_score&&best_score!=-1){break;}}if(best_score==-1||score<best_score){best_score=score; for(std::size_t i=num_duels;i-->0;){duel_pairs[i][0]=&tournament.participant_at_index(shuffled_jedi[2*i+1]);duel_pairs[i][1]=&tournament.participant_at_index(shuffled_jedi[2*i]);}}}}}
/*--------------------------------------*/

#ifndef PA08_PAIRINGALGORITHMS_HPP_#define PA08_PAIRINGALGORITHMS_HPP_#include""#include""namespace pa08{void pairing_algorithm_greedy(JediTournament const&tournament,int const(&score_matrix)[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS],Jedi const*duel_pairs[][2]);void pairing_algorithm_greedy(JediTournament const&&tournament,int const(&score_matrix)[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS],Jedi const*duel_pairs[][2])=delete;void pairing_algorithm_random(JediTournament const&tournament,int const(&score_matrix)[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS],Jedi const*duel_pairs[][2],unsigned int num_iterations);void pairing_algorithm_random(JediTournament const&&tournament,int const(&score_matrix)[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS],Jedi const*duel_pairs[][2],unsigned int num_iterations)=delete;}#endif
/*--------------------------------------*/

#include""#include""#include""#include""#include""#include<iostream>#include<limits>#include<string>namespace pa08{void run_ui_to_completion(){JediTournament tournament;std::cout<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<JediTournament::MAX_NUM_PARTICIPANTS<<""<<std::endl;bool should_exit;do{std::cout<<std::endl;display_menu(tournament,should_exit);}while(!should_exit);}void display_menu(JediTournament&tournament,bool&should_exit){std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<std::endl;int const user_option=util::get_user_input_in_range(1,3);std::cout<<std::endl;switch(user_option){case 1:user_add_jedi_participant(tournament);break;case 2:user_generate_pairings(tournament);break;case 3:should_exit=true;break;}}void user_add_jedi_participant(JediTournament&tournament){if(tournament.num_participants()>=JediTournament::MAX_NUM_PARTICIPANTS){ std::cout<<""<<JediTournament::MAX_NUM_PARTICIPANTS<<""<<std::endl;return;}std::string user_jedi_lightsaber_color;std::string user_jedi_name;int user_jedi_skill_level;int user_jedi_force_strength;std::cout<<"";std::cin>>user_jedi_lightsaber_color;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');std::cout<<"";std::getline(std::cin,user_jedi_name);std::cout<<"";std::cin>>user_jedi_skill_level;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');std::cout<<"";std::cin>>user_jedi_force_strength;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');Jedi jedi_to_add{static_cast<std::string&&>(user_jedi_name),static_cast<std::string&&>(user_jedi_lightsaber_color),user_jedi_skill_level,user_jedi_force_strength};tournament.add_participant(static_cast<Jedi&&>(jedi_to_add));}void user_generate_pairings(JediTournament const&tournament){bool const has_no_participants=tournament.num_participants()==0;bool const has_odd_num_participants=tournament.num_participants()&1;if(has_no_participants||has_odd_num_participants){ std::cout<<""""<<std::endl;std::cout<<""<<tournament.num_participants()<<""<<(tournament.num_participants()==1?"":"")<<""<<std::endl;return;}std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<""<<std::endl;std::cout<<std::endl;int const user_option=util::get_user_input_in_range(1,2);std::cout<<std::endl;int score_matrix[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS];Jedi const*duel_pairs[JediTournament::MAX_NUM_PARTICIPANTS/2][2];tournament.create_score_matrix(score_matrix);{switch(user_option){case 1:pairing_algorithm_greedy(tournament,score_matrix,duel_pairs);break;case 2: std::cout<<""<<std::endl;int const user_num_iterations=util::get_user_input_in_range(1,std::numeric_limits<int>::max());std::cout<<""<<std::endl;int const user_prng_seed=util::get_user_input_in_range(-1,std::numeric_limits<int>::max());bool const preserve_seed=user_prng_seed==-1;if(!preserve_seed){std::srand(static_cast<unsigned int>(user_prng_seed));}pairing_algorithm_random(tournament,score_matrix,duel_pairs,user_num_iterations);std::cout<<std::endl;break;}}std::size_t const num_duels=tournament.num_participants()/2;display_pairings(tournament,score_matrix,duel_pairs,num_duels);}void display_pairings(JediTournament const&tournament,int const(&score_matrix)[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS],Jedi const*duel_pairs[][2],std::size_t const num_duels){std::cout<<""<<num_duels<<""<<std::endl;int total_score=0;for(std::size_t i=0;i<num_duels;++i){Jedi const&jedi1=*duel_pairs[i][0];Jedi const&jedi2=*duel_pairs[i][1]; std::size_t const jedi1_index=&jedi1-&tournament.participant_at_index(0);std::size_t const jedi2_index=&jedi2-&tournament.participant_at_index(0);int const score_to_add=score_matrix[jedi1_index][jedi2_index];total_score+=score_to_add;std::cout<<""<<jedi1.name<<""<<jedi1.skill_level<<""<<jedi1.force_strength<<""<<jedi1.lightsaber_color<<""<<jedi2.name<<""<<jedi2.skill_level<<""<<jedi2.force_strength<<""<<jedi2.lightsaber_color<<""<<score_to_add<<std::endl;}std::cout<<""<<total_score<<std::endl;}}
/*--------------------------------------*/

#ifndef PA08_USERINTERFACE_HPP_#define PA08_USERINTERFACE_HPP_#include""#include""namespace pa08{void run_ui_to_completion();void display_menu(JediTournament&tournament,bool&should_exit);void user_add_jedi_participant(JediTournament&tournament);void user_generate_pairings(JediTournament const&tournament);void display_pairings(JediTournament const&tournament,int const(&score_matrix)[JediTournament::MAX_NUM_PARTICIPANTS][JediTournament::MAX_NUM_PARTICIPANTS],Jedi const*duel_pairs[][2],std::size_t num_duels);}#endif
/*--------------------------------------*/

#include<iostream>#include<limits>namespace pa08{namespace util{int get_user_input_in_range(int const min,int const max){int user_num;bool valid_input_given;do{std::cout<<""<<min<<""<<max<<"";std::cin>>user_num;std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'');valid_input_given=min<=user_num&&user_num<=max;if(!valid_input_given){ std::cout<<"";}}while(!valid_input_given);return user_num;}}}
/*--------------------------------------*/

#ifndef PA08_UTIL_USERINPUT_HPP_#define PA08_UTIL_USERINPUT_HPP_ namespace pa08{namespace util{int get_user_input_in_range(int min,int max);}}#endif
